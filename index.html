<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/zhaoqixing/my-blog.git/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/my-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/my-blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blog/">Home</a>
        
          <a class="main-nav-link" href="/my-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/zhaoqixing/my-blog.git"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Feign配置问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/07/19/Feign配置问题/" class="article-date">
  <time datetime="2019-07-19T09:55:04.378Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/07/19/Feign配置问题/">Feign配置问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h3><pre><code># 设置连接超时时间
ribbon.ConnectTimeout=600
# 设置读取超时时间
ribbon.ReadTimeout=6000
# 对所有操作请求都进行重试
ribbon.OkToRetryOnAllOperations=true
# 切换实例的重试次数
ribbon.MaxAutoRetriesNextServer=2
# 对当前实例的重试次数
ribbon.MaxAutoRetries=1
</code></pre><p>如果我想针对不同的服务配置不同的连接超时和读取超时，那么我们可以在属性的前面加上服务的名字，如下：</p>
<pre><code># 设置针对hello-service服务的连接超时时间
hello-service.ribbon.ConnectTimeout=600
# 设置针对hello-service服务的读取超时时间
hello-service.ribbon.ReadTimeout=6000
# 设置针对hello-service服务所有操作请求都进行重试
hello-service.ribbon.OkToRetryOnAllOperations=true
# 设置针对hello-service服务切换实例的重试次数
hello-service.ribbon.MaxAutoRetriesNextServer=2
# 设置针对hello-service服务的当前实例的重试次数
hello-service.ribbon.MaxAutoRetries=1
</code></pre><h3 id="Hystrix配置"><a href="#Hystrix配置" class="headerlink" title="Hystrix配置"></a>Hystrix配置</h3><pre><code># 设置熔断超时时间
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
# 关闭Hystrix功能（不要和上面的配置一起使用）
feign.hystrix.enabled=false
# 关闭熔断功能
hystrix.command.default.execution.timeout.enabled=false
</code></pre><p>这种配置也是全局配置，如果我们想针对某一个接口配置，比如/hello接口，那么可以按照下面这种写法，如下：</p>
<pre><code># 设置熔断超时时间
hystrix.command.hello.execution.isolation.thread.timeoutInMilliseconds=10000
# 关闭熔断功能
hystrix.command.hello.execution.timeout.enabled=false
</code></pre><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>Spring Cloud Feign支持对请求和响应进行GZIP压缩，以提高通信效率，配置方式如下：</p>
<pre><code># 配置请求GZIP压缩
feign.compression.request.enabled=true
# 配置响应GZIP压缩
feign.compression.response.enabled=true
# 配置压缩支持的MIME TYPE
feign.compression.request.mime-types=text/xml,application/xml,application/json
# 配置压缩数据大小的下限
feign.compression.request.min-request-size=2048
</code></pre><h3 id="hystrix参数如下"><a href="#hystrix参数如下" class="headerlink" title="hystrix参数如下"></a>hystrix参数如下</h3><pre><code>hystrix.command.default和hystrix.threadpool.default中的default为默认CommandKey

Command Properties
Execution相关的属性的配置：
hystrix.command.default.execution.isolation.strategy 隔离策略，默认是Thread, 可选Thread｜Semaphore

hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时间，默认1000ms

hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true
hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断，默认true
hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 最大并发请求数，默认10，该参数
当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。理论上
选择semaphore size的原则和选择thread size一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），
否则的话应该用thread。

semaphore应该占整个容器（tomcat）的线程池的一小部分。
Fallback相关的属性
这些参数可以应用于Hystrix的THREAD和SEMAPHORE策略

hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 如果并发数达到该设置值，请求会
被拒绝和抛出异常并且fallback不会被调用。默认10

hystrix.command.default.fallback.enabled 当执行失败或者请求被拒绝，是否会尝试调用hystrixCommand.getFallback() 。默认true

Circuit Breaker相关的属性
hystrix.command.default.circuitBreaker.enabled 用来跟踪circuit的健康性，如果未达标则让request短路。默认true
hystrix.command.default.circuitBreaker.requestVolumeThreshold 一个rolling window内最小的请求数。如果设为20，那么
当一个rolling window的时间内（比如说1个rolling window是10秒）收到19个请求，即使19个请求都失败，也不会
触发circuit break。默认20

hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 触发短路的时间值，当该值设为5000时，则当触
发circuit break后的5000毫秒内都会拒绝request，也就是5000毫秒后才会关闭circuit。默认5000

hystrix.command.default.circuitBreaker.errorThresholdPercentage错误比率阀值，如果错误率&gt;=该值，circuit会被打
开，并短路所有请求触发fallback。默认50

hystrix.command.default.circuitBreaker.forceOpen 强制打开熔断器，如果打开这个开关，那么拒绝所有request，默认false

hystrix.command.default.circuitBreaker.forceClosed 强制关闭熔断器 如果这个开关打开，circuit将一直关闭且
忽略circuitBreaker.errorThresholdPercentage

Metrics相关参数
hystrix.command.default.metrics.rollingStats.timeInMilliseconds 设置统计的时间窗口值的，毫秒值，circuit break 的
打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，
每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000

hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，
若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10

hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true
hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000
hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。
默认6

hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，
只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100

hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，
默认500ms

Request Context 相关参数

hystrix.command.default.requestCache.enabled 默认true，需要重载getCacheKey()，返回null时不缓存
hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true

Collapser Properties 相关参数
hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE
hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10
hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，
默认true

ThreadPool 相关参数
线程数默认值10适用于大部分情况（有时可以设置得更小），如果需要设置得更大，那有个基本得公式可以follow：
requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room
每秒最大支撑的请求数 (99%平均响应时间 + 缓存值)
比如：每秒能处理1000个请求，99%的请求响应时间是60ms，那么公式是：
（0.060+0.012）

基本得原则时保持线程池尽可能小，他主要是为了释放压力，防止资源被阻塞。
当一切都是正常的时候，线程池一般仅会有1到2个线程激活来提供服务

hystrix.threadpool.default.coreSize 并发执行的最大线程数，默认10
hystrix.threadpool.default.maxQueueSize BlockingQueue的最大队列数，当设为－1，会使用SynchronousQueue，值为正时
使用LinkedBlcokingQueue。该设置只会在初始化时有效，之后不能修改threadpool的queue size，
除非reinitialising thread executor。默认－1。

hystrix.threadpool.default.queueSizeRejectionThreshold 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该
值后，请求也会被拒绝。因为maxQueueSize不能被动态修改，这个参数将允许我们动态设置该值。if maxQueueSize == -1，
该字段将不起作用

hystrix.threadpool.default.keepAliveTimeMinutes 如果corePoolSize和maxPoolSize设成一样（默认实现）该设置无效。
如果通过plugin（https://github.com/Netflix/Hystrix/wiki/Plugins）使用自定义实现，该设置才有用，默认1.

hystrix.threadpool.default.metrics.rollingStats.timeInMilliseconds 线程池统计指标的时间，默认10000
hystrix.threadpool.default.metrics.rollingStats.numBuckets 将rolling window划分为n个buckets，默认10
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/07/19/Feign配置问题/" data-id="cjy9xsode0007r4v8jpqpi45m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cleanup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/07/05/Cleanup/" class="article-date">
  <time datetime="2019-07-05T10:47:14.741Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/07/05/Cleanup/">cleanup 自动资源管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没有麻烦和安全地调用您的close()方法.</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>可以使用@Cleanup以确保在代码执行路径退出当前作用域之前自动清除给定资源。您可以通过使用@Cleanup注释任何局部变量声明来执行此操作：<br>@Cleanup InputStream in = new FileInputStream(“some/file”);<br>结果，在您作用域范围的末尾调用in.close()。保证通过try / finally构造运行此调用。请看下面的示例，看看它是如何工作的。<br>如果要清理的对象类型没有close()方法，但是有其他一些无参数方法，则可以指定此方法的名称，如下所示：<br>@Cleanup(“dispose”) org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0);<br>默认情况下，清除方法被假定为close()。@Cleanup无法调用带有1个或多个参数的清理方法。</p>
<h4 id="With-Lombok"><a href="#With-Lombok" class="headerlink" title="With Lombok"></a>With Lombok</h4><pre><code>import lombok.Cleanup;
import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
      int r = in.read(b);
      if (r == -1) break;
      out.write(b, 0, r);
    }
  }
}
</code></pre><h4 id="Vanilla-Java"><a href="#Vanilla-Java" class="headerlink" title="Vanilla Java"></a>Vanilla Java</h4><pre><code>import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    InputStream in = new FileInputStream(args[0]);
    try {
      OutputStream out = new FileOutputStream(args[1]);
      try {
        byte[] b = new byte[10000];
        while (true) {
          int r = in.read(b);
          if (r == -1) break;
          out.write(b, 0, r);
        }
      } finally {
        if (out != null) {
          out.close();
        }
      }
    } finally {
      if (in != null) {
        in.close();
      }
    }
  }
}
</code></pre><h4 id="Supported-configuration-keys"><a href="#Supported-configuration-keys" class="headerlink" title="Supported configuration keys:"></a>Supported configuration keys:</h4><p>lombok.cleanup.flagUsage = [warning | error] (default: not set)<br>如果配置， Lombok会将任何@Cleanup用法标记为警告或错误。</p>
<h4 id="Small-print"><a href="#Small-print" class="headerlink" title="Small print"></a>Small print</h4><p>在finally块中，只有在给定资源不是null的情况下才会调用cleanup方法。但是，如果您使用delombok在代码上，则插入lombok.Lombok.preventNullAnalysis(Object o)调用以防止警告，如果静态代码分析可以确定，则不需要进行 null-check。使用 lombok.jar 类路径进行编译会删除该方法调用，因此不存在运行时依赖性。<br>如果您的代码抛出异常，并且随后触发的清理方法调用也会抛出异常，则清理调用抛出的异常将隐藏原始异常。你不应该依赖这个“功能”。最好是，lombok想生成代码，这样，如果主体抛出了异常，那么关闭调用抛出的任何异常都会被静默吞噬（但如果主体以任何其他方式退出，则关闭调用的异常将不会是吞咽）。lombok的作者目前不知道实现这个方案的可行方法，但是如果java更新允许它，或者我们找到了一种方法，我们将修复它。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/07/05/Cleanup/" data-id="cjy9xsocq0000r4v87hv7gv1g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring Boot实现confirm机制及ack消费端主动回调" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/28/Spring Boot实现confirm机制及ack消费端主动回调/" class="article-date">
  <time datetime="2019-06-28T11:11:53.264Z" itemprop="datePublished">2019-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/28/Spring Boot实现confirm机制及ack消费端主动回调/">RabbitMQ数据丢失问题，Spring Boot实现confirm机制及ack消费端主动回调</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-说明：ACK是默认是自动，在消息发送给消费者后立即确认。所以若消费端消费业务逻辑抛出异常，会可能丢失消息。即便加入事务回滚了也只保证数据的一致性，而消息依然丢失。所以，若消费端未成功处理此条消息，消息就会丢失。"><a href="#1-说明：ACK是默认是自动，在消息发送给消费者后立即确认。所以若消费端消费业务逻辑抛出异常，会可能丢失消息。即便加入事务回滚了也只保证数据的一致性，而消息依然丢失。所以，若消费端未成功处理此条消息，消息就会丢失。" class="headerlink" title="1:说明：ACK是默认是自动，在消息发送给消费者后立即确认。所以若消费端消费业务逻辑抛出异常，会可能丢失消息。即便加入事务回滚了也只保证数据的一致性，而消息依然丢失。所以，若消费端未成功处理此条消息，消息就会丢失。"></a>1:说明：ACK是默认是自动，在消息发送给消费者后立即确认。所以若消费端消费业务逻辑抛出异常，会可能丢失消息。即便加入事务回滚了也只保证数据的一致性，而消息依然丢失。所以，若消费端未成功处理此条消息，消息就会丢失。</h4><p>  NONE（默认）：自动；AUTO：根据情况确认；MANUAL：手动确认</p>
<h4 id="2-yml配置："><a href="#2-yml配置：" class="headerlink" title="2:yml配置："></a>2:yml配置：</h4><pre><code>spring: rabbitmq: host: 127.0.0.1 
port: 5672 
username: guest 
password: guest 
#发送确认 对应RabbitTemplate.ConfirmCallback接口 
publisher-confirms: true 
#发送失败回退，对应RabbitTemplate.ReturnCallback接口 
publisher-returns: true 
#手动提交ack 
listener: 
   direct: 
       #NONE（默认）：自动；AUTO：根据情况确认；MANUAL：手动确认 
       acknowledge-mode: manual 
   simple: 
       acknowledge-mode: manual
</code></pre><h4 id="3-config配置："><a href="#3-config配置：" class="headerlink" title="3:config配置："></a>3:config配置：</h4><pre><code>@Configuration public class RabbitConfig { /**
     * 定义一个队列
     * @return
     */ 
     @Bean 
     public Queue okongQueue() { 
        return new Queue(&quot;user&quot;); 
     } 
     @Bean 
     MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter(); 
     }
 }
</code></pre><h4 id="4-发送端："><a href="#4-发送端：" class="headerlink" title="4:发送端："></a>4:发送端：</h4><pre><code>@Service
public class SenderService implements RabbitTemplate.ConfirmCallback,
    RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMq() throws InterruptedException {
        this.rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.convertAndSend(&quot;user&quot;, &quot;6666666&quot;);
    }

    @Override
    public void confirm(CorrelationData correlationData, boolean ack,
        String cause) {
        System.out.println(&quot;=====已消费======&quot;);

        if (ack) {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，已经被ack成功&quot;);
        } else {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，nack，失败原因是：&quot; +
                cause);
        }
    }

    @Override
    public void returnedMessage(Message message, int replyCode,
        String replyText, String exchange, String routingKey) {
        System.out.println(&quot;sender return success&quot; + message.toString());
    }
}
</code></pre><h4 id="5：消费端"><a href="#5：消费端" class="headerlink" title="5：消费端"></a>5：消费端</h4><pre><code>@Service
public class SenderService implements RabbitTemplate.ConfirmCallback,
    RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMq() throws InterruptedException {
        this.rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.convertAndSend(&quot;user&quot;, &quot;6666666&quot;);
    }

    @Override
    public void confirm(CorrelationData correlationData, boolean ack,
        String cause) {
        System.out.println(&quot;=====已消费======&quot;);

        if (ack) {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，已经被ack成功&quot;);
        } else {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，nack，失败原因是：&quot; +
                cause);
        }
    }

    @Override
    public void returnedMessage(Message message, int replyCode,
        String replyText, String exchange, String routingKey) {
        System.out.println(&quot;sender return success&quot; + message.toString());
    }
}
</code></pre><p>还可指定以下处理方式，可参考api：</p>
<pre><code>@Service
public class SenderService implements RabbitTemplate.ConfirmCallback,
    RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMq() throws InterruptedException {
        this.rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.convertAndSend(&quot;user&quot;, &quot;6666666&quot;);
    }

    @Override
    public void confirm(CorrelationData correlationData, boolean ack,
        String cause) {
        System.out.println(&quot;=====已消费======&quot;);

        if (ack) {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，已经被ack成功&quot;);
        } else {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，nack，失败原因是：&quot; +
                cause);
        }
    }

    @Override
    public void returnedMessage(Message message, int replyCode,
        String replyText, String exchange, String routingKey) {
        System.out.println(&quot;sender return success&quot; + message.toString());
    }
}
</code></pre><p>参数说明：</p>
<p>basicAck 方法需要传递两个参数<br>deliveryTag（唯一标识 ID）：当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， 它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel<br>multiple：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</p>
<p>basicNack方法需要传递三个参数<br>deliveryTag（唯一标识 ID）：同上<br>multiple：同上<br>requeue： true ：重回队列，false ：丢弃，我们在nack方法中必须设置 false，否则重发没有意义。</p>
<p>basicReject方法需要传递两个参数<br>deliveryTag（唯一标识 ID）：同上<br>requeue：同上</p>
<h4 id="6：指定控制层调用："><a href="#6：指定控制层调用：" class="headerlink" title="6：指定控制层调用："></a>6：指定控制层调用：</h4><pre><code>@Service
public class SenderService implements RabbitTemplate.ConfirmCallback,
    RabbitTemplate.ReturnCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMq() throws InterruptedException {
        this.rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.convertAndSend(&quot;user&quot;, &quot;6666666&quot;);
    }

    @Override
    public void confirm(CorrelationData correlationData, boolean ack,
        String cause) {
        System.out.println(&quot;=====已消费======&quot;);

        if (ack) {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，已经被ack成功&quot;);
        } else {
            System.out.println(&quot;消息: &quot; + correlationData + &quot;，nack，失败原因是：&quot; +
                cause);
        }
    }

    @Override
    public void returnedMessage(Message message, int replyCode,
        String replyText, String exchange, String routingKey) {
        System.out.println(&quot;sender return success&quot; + message.toString());
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/06/28/Spring Boot实现confirm机制及ack消费端主动回调/" data-id="cjy9xsocz0001r4v8zmolbdgc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-适配器模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/21/适配器模式/" class="article-date">
  <time datetime="2019-06-21T11:12:30.389Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/21/适配器模式/">适配器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><pre><code>适配器模式将一个类的接口，转换为客户期望的另一个接口。适配器让原本不兼容的类可以合作无间
</code></pre><h4 id="2、解决问题"><a href="#2、解决问题" class="headerlink" title="2、解决问题"></a>2、解决问题</h4><pre><code>从模式的定义中，我们看到适配器模式就是用来转换接口，解决不兼容问题的。想想我们现实生活中的适配器，最常用的就是手机充电器了，也叫做电源适配器，它把家用交流强电转换为手机用的直流弱电。其中交流电就是被适配者，充电器是适配器，手机是用电客户。
</code></pre><h4 id="3、成员角色"><a href="#3、成员角色" class="headerlink" title="3、成员角色"></a>3、成员角色</h4><pre><code>　客户（Client）：只能调用目标接口功能，不能直接使用被适配器，但可以通过适配器的接口转换间接使用被适配器。

　　目标接口（Target）：客户看到的接口，适配器必须实现该接口才能被客户使用。

　　适配器（Adapter）：适配器把被适配者接口转换为目标接口，提供给客户使用。

　　被适配者（Adaptee）：被适配者接口与目标接口不兼容，需要适配器转换成目标接口子类，才能被客户使用。
</code></pre><h4 id="4、应用实例"><a href="#4、应用实例" class="headerlink" title="4、应用实例"></a>4、应用实例</h4><p>下面用鸟叫和鸟飞的例子解析适配器模式，鹦鹉会叫也会飞，但鹅就只会叫不会飞，而且鹅也不是鸟类，我们要创建一个适配器，把鹅转换成鸟。</p>
<p>　　第一步、创建鸟接口，对应角色目标接口</p>
<pre><code>package adapter.pattern;

//鸟接口
public interface Bird {
    //鸟叫
    public void chirp();
    //飞
    public void fly();
}
</code></pre><p>第二步、创建鹦鹉类</p>
<pre><code>package adapter.pattern;

//鹦鹉类实现鸟接口
public class Parrot implements Bird{

    public void chirp() {
        System.out.println(&quot;呜呜呜&quot;);     
    }

    public void fly() {
        System.out.println(&quot;我能飞很远很远&quot;);     
    }

}
</code></pre><p>第三步、创建鹅类，对应角色被适配者</p>
<pre><code>package adapter.pattern;

//鹅类，不是鸟
public class Goose {
    //鹅会叫但不会飞，没有飞的方法
    public void chirp(){
        System.out.println(&quot;嘎嘎嘎&quot;);
    }
}
</code></pre><p>第四步、创建适配器</p>
<pre><code>package adapter.pattern;

//适配器，把鹅类适配为鸟
public class GooseAdapter implements Bird{
    //组合鹅类
    Goose goose;
    public GooseAdapter(Goose goose){
        this.goose = goose;
    }

    public void chirp() {
        if(goose != null){
            //调用鸟叫的时候委托鹅叫
            goose.chirp();
        }
    }

    public void fly() {
        //不支持该操作，可以抛出该异常，客户可以知道详情
        throw new UnsupportedOperationException();
    }

}
</code></pre><p>第五步、测试适配器</p>
<pre><code>package adapter.pattern;

public class AdapterTest {
    public static void main(String[] args){
        System.out.println(&quot;-----鹦鹉会叫也会飞-----&quot;);
        Bird parrot = new Parrot();
        parrot.chirp();
        parrot.fly();

        System.out.println(&quot;-----鹅会叫但不会飞-----&quot;);
        Goose goose = new Goose();
        Bird gooseAdapter = new GooseAdapter(goose);
        gooseAdapter.chirp();
        gooseAdapter.fly();


    }
}

 -----鹦鹉会叫也会飞-----
 呜呜呜
 -----鹅会叫但不会飞-----
 嘎嘎嘎
</code></pre><p>适配器在java中的例子，我们知道ArrayList类实现了迭代器（Iterator），但不支持枚举（Enumeration），下面我们就来实现ArrayList的枚举操作。</p>
<pre><code>package adapter.pattern;

import java.util.ArrayList;
import java.util.Enumeration;

public class ItertorEnumeration implements Enumeration{
    //组合被适配者
    private ArrayList&lt;String&gt; list;
    //集合的计数器，判断指针指向集合的位置
    private int index = 0;
    public ItertorEnumeration(ArrayList&lt;String&gt; list){
        this.list = list;
    }
    public boolean hasMoreElements() {
        if(list != null &amp;&amp; list.size() &gt; index){
            return true;
        }
        return false;
    }

    public Object nextElement() {
        String content = list.get(index);
        index++;
        return content;
    }
}
</code></pre><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p>　　1、优点</p>
<p>　　（1）、转换接口，适配器让不兼容的接口变成兼容。</p>
<p>　　（2）、让客户和实现的接口解耦。有了适配器，客户端每次调用不兼容的接口时，不用修改自己的代码，只要调用适合的适配器就可以了。</p>
<p>　　（3）、使用了对象组合设计原则。以组合的方式包装被适配者，被适配者的任何子类都可以搭配着同一个适配器使用。</p>
<p>　　（4）、体现了“开闭”原则。适配器模式把客户和接口绑定起来，而不是和具体实现绑定，我们可以使用多个配适器来转换多个后台类，也可以很容易地增加新的适配器。</p>
<p>　　2、缺点</p>
<p>　　（1）、每个被适配者都需要一个适配器，当适配器过多时会增加系统复杂度，降低运行时的性能。</p>
<p>　　（2）、实现一个适配器可能需要下一番功夫，增加开发的难度。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1、当要使用的两个类所做的事情相同或者相似，但是具有不同的接口时考虑使用配适器模式。</p>
<p>　　2、当需要统一客户端调用接口的代码，而所调用的接口具有不兼容问题时使用适配器模式。这样客户端只有调用一个接口就行了，这样可以更简单、更直接、更紧凑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/06/21/适配器模式/" data-id="cjy9xsod70006r4v8qvish90l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-commons-lang3-3.2.jar中的常用工具类的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/14/commons-lang3-3.2.jar中的常用工具类的使用/" class="article-date">
  <time datetime="2019-06-14T13:15:14.379Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/14/commons-lang3-3.2.jar中的常用工具类的使用/">commons-lang3-3.2.jar中的常用工具类的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、StringUtils工具类"><a href="#1、StringUtils工具类" class="headerlink" title="1、StringUtils工具类"></a>1、StringUtils工具类</h4><p>可以判断是否是空串，是否为null，默认值设置等操作:</p>
<pre><code>/**
     * StringUtils
     */
    public static void test1() {
        System.out.println(StringUtils.isBlank(&quot;   &quot;));// true----可以验证null, &quot;&quot;,&quot; &quot;等
        System.out.println(StringUtils.isBlank(&quot;null&quot;));// false
        System.out.println(StringUtils.isAllLowerCase(&quot;null&quot;));// t
        System.out.println(StringUtils.isAllUpperCase(&quot;XXXXXX&quot;));// t
        System.out.println(StringUtils.isEmpty(&quot; &quot;));// f---为null或者&quot;&quot;返回true
        System.out.println(StringUtils.defaultIfEmpty(null, &quot;default&quot;));// 第二个参数是第一个为null或者&quot;&quot;的时候的取值
        System.out.println(StringUtils.defaultIfBlank(&quot;    &quot;, &quot;default&quot;));//// 第二个参数是第一个为null或者&quot;&quot;或者&quot;   &quot;的时候的取值
    }
</code></pre><p>isBlank()  可以验证空格、null、””，如果是好几个空格也返回true</p>
<p>isEmpty验证不了空格，只有值为null和””返回true </p>
<p>两者都验证不了”null”字符串，所以如果验证”null”还需要自己用equals进行验证。</p>
<pre><code>结果:

true
false
true
true
false
default
default
</code></pre><p>简单的贴出几个源码便于记录:</p>
<pre><code>public static boolean isBlank(final CharSequence cs) {
        int strLen;
        if (cs == null || (strLen = cs.length()) == 0) {
            return true;
        }
        for (int i = 0; i &lt; strLen; i++) {
            if (Character.isWhitespace(cs.charAt(i)) == false) {
                return false;
            }
        }
        return true;
    }

    public static boolean isEmpty(final CharSequence cs) {
        return cs == null || cs.length() == 0;
    }


       public static String defaultIfEmpty(String str, String defaultStr) {
            return StringUtils.isEmpty(str) ? defaultStr : str;
        }
</code></pre><p>CharSequence是一个接口，String,StringBuffer,StringBuilder等都实现了此接口</p>
<pre><code>public abstract interface CharSequence {
    public abstract int length();

    public abstract char charAt(int paramInt);

    public abstract CharSequence subSequence(int paramInt1, int paramInt2);

    public abstract String toString();
}
</code></pre><p>补充:StringUtils页可以将集合转为String，并且以指定符号链接里面的数据</p>
<pre><code>List list = new ArrayList(2);
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        String list2str = StringUtils.join(list, &quot;,&quot;);
        System.out.println(list2str);

结果:

　　张三,李四,王五
</code></pre><p>补充:有时候我们希望给拼接后的字符串都加上单引号，这个在拼接SQL  in条件的时候非常有用，例如:</p>
<pre><code>    //需求:将逗号里面的内容都加上单引号
    String string = &quot;111,222,333&quot;;
    string = &quot;&apos;&quot;+string+&quot;&apos;&quot;;//字符串前后加&apos;
    string = StringUtils.join(string.split(&quot;,&quot;),&quot;&apos;,&apos;&quot;);//先按逗号分隔为数组，然后用&apos;,&apos;连接数组
    System.out.println(string);

结果:

&apos;111&apos;,&apos;222&apos;,&apos;333&apos;
</code></pre><p>补充:String.format(format,Object)也可以对字符串进行格式化，例如在数字前面补齐数字</p>
<pre><code>        int num = 50;
        String format = String.format(&quot;%0&quot; + 5 + &quot;d&quot;, num);
        System.out.println(format);

结果:

00050
</code></pre><p>补充:StringUtils也可以截取字符串,判断是否大小写等操作</p>
<pre><code>String string = &quot;123_45_43_ss&quot;;
        System.out.println(StringUtils.isAllLowerCase(string));// 判断全部小写
        System.out.println(StringUtils.isAllUpperCase(string));// 判断全部大写
        System.out.println(StringUtils.substringAfter(string, &quot;123&quot;));// 截取123之后的
        System.out.println(StringUtils.substringBefore(string, &quot;45&quot;));// 截取45之前的
        System.out.println(StringUtils.substringBefore(string, &quot;_&quot;));// 截取第一个_之前的
        System.out.println(StringUtils.substringBeforeLast(string, &quot;_&quot;));// 截取最后一个_之前的
        System.out.println(StringUtils.substringAfter(string, &quot;_&quot;));// 截取第一个_之后的
        System.out.println(StringUtils.substringAfterLast(string, &quot;_&quot;));// 截取最后一个_之后的
        System.out.println(StringUtils.substringBetween(&quot;1234565432123456&quot;, &quot;2&quot;, &quot;6&quot;));// 截取两个之间的(都找的是第一个)
</code></pre><h4 id="2-StringEscapeUtils———-转义字符串的工具类"><a href="#2-StringEscapeUtils———-转义字符串的工具类" class="headerlink" title="2.StringEscapeUtils———-转义字符串的工具类"></a>2.StringEscapeUtils———-转义字符串的工具类</h4><pre><code>/**
     * StringEscapeUtils
     */
    public static  void test2(){
        //1.防止sql注入------原理是将&apos;替换为&apos;&apos;
        System.out.println(org.apache.commons.lang.StringEscapeUtils.escapeSql(&quot;sss&quot;));
        //2.转义/反转义html
        System.out.println( org.apache.commons.lang.StringEscapeUtils.escapeHtml(&quot;&lt;a&gt;dddd&lt;/a&gt;&quot;));   //&amp;lt;a&amp;gt;dddd&amp;lt;/a&amp;gt;
        System.out.println(org.apache.commons.lang.StringEscapeUtils.unescapeHtml(&quot;&amp;lt;a&amp;gt;dddd&amp;lt;/a&amp;gt;&quot;));  //&lt;a&gt;dddd&lt;/a&gt;
        //3.转义/反转义JS
        System.out.println(org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(&quot;&lt;script&gt;alert(&apos;1111&apos;)&lt;/script&gt;&quot;));   
        //4.把字符串转为unicode编码
        System.out.println(org.apache.commons.lang.StringEscapeUtils.escapeJava(&quot;中国&quot;));   
        System.out.println(org.apache.commons.lang.StringEscapeUtils.unescapeJava(&quot;\u4E2D\u56FD&quot;));  
        //5.转义JSON
        System.out.println(org.apache.commons.lang3.StringEscapeUtils.escapeJson(&quot;{name:&apos;qlq&apos;}&quot;));   
    }
</code></pre><h4 id="3-NumberUtils——–字符串转数据或者判断字符串是否是数字常用工具类"><a href="#3-NumberUtils——–字符串转数据或者判断字符串是否是数字常用工具类" class="headerlink" title="3.NumberUtils——–字符串转数据或者判断字符串是否是数字常用工具类"></a>3.NumberUtils——–字符串转数据或者判断字符串是否是数字常用工具类</h4><pre><code>/**
     * NumberUtils
     */
    public static  void test3(){
        System.out.println(NumberUtils.isNumber(&quot;231232.8&quot;));//true---判断是否是数字
        System.out.println(NumberUtils.isDigits(&quot;2312332.5&quot;));//false，判断是否是整数
        System.out.println(NumberUtils.toDouble(null));//如果传的值不正确返回一个默认值，字符串转double，传的不正确会返回默认值
        System.out.println(NumberUtils.createBigDecimal(&quot;333333&quot;));//字符串转bigdecimal
    }
</code></pre><h4 id="4-BooleanUtils————判断Boolean类型工具类"><a href="#4-BooleanUtils————判断Boolean类型工具类" class="headerlink" title="4.BooleanUtils————判断Boolean类型工具类"></a>4.BooleanUtils————判断Boolean类型工具类</h4><pre><code>/**
     * BooleanUtils
     */
    public static  void test4(){
        System.out.println(BooleanUtils.isFalse(true));//false
        System.out.println(BooleanUtils.toBoolean(&quot;yes&quot;));//true
        System.out.println(BooleanUtils.toBooleanObject(0));//false
        System.out.println(BooleanUtils.toStringYesNo(false));//no
        System.out.println(BooleanUtils.toBooleanObject(&quot;ok&quot;, &quot;ok&quot;, &quot;error&quot;, &quot;null&quot;));//true-----第一个参数是需要验证的字符串，第二个是返回true的值，第三个是返回false的值，第四个是返回null的值
    }
</code></pre><h4 id="5-SystemUtils—-获取系统信息-原理都是调用System-getProperty"><a href="#5-SystemUtils—-获取系统信息-原理都是调用System-getProperty" class="headerlink" title="5.SystemUtils—-获取系统信息(原理都是调用System.getProperty())"></a>5.SystemUtils—-获取系统信息(原理都是调用System.getProperty())</h4><pre><code>/**
     * SystemUtils
     */
    public static  void test5(){
        System.out.println(SystemUtils.getJavaHome());
        System.out.println(SystemUtils.getJavaIoTmpDir());
        System.out.println(SystemUtils.getUserDir());
        System.out.println(SystemUtils.getUserHome());
        System.out.println(SystemUtils.JAVA_VERSION);
        System.out.println(SystemUtils.OS_NAME);
        System.out.println(SystemUtils.USER_TIMEZONE);
    }
</code></pre><h4 id="6-DateUtils和DateFormatUtils可以实现字符串转date与date转字符串-date比较先后问题"><a href="#6-DateUtils和DateFormatUtils可以实现字符串转date与date转字符串-date比较先后问题" class="headerlink" title="6.DateUtils和DateFormatUtils可以实现字符串转date与date转字符串,date比较先后问题"></a>6.DateUtils和DateFormatUtils可以实现字符串转date与date转字符串,date比较先后问题</h4><p>DateUtils也可以判断是否是同一天等操作。</p>
<pre><code>package zd.dms.test;

import java.text.ParseException;
import java.util.Date;

import org.apache.commons.lang3.time.DateFormatUtils;
import org.apache.commons.lang3.time.DateUtils;

public class PlainTest {
    public static void main(String[] args) {
        // DateFormatUtils----date转字符串
        Date date = new Date();
        System.out.println(DateFormatUtils.format(date, &quot;yyyy-MM-dd hh:mm:ss&quot;));// 小写的是12小时制
        System.out.println(DateFormatUtils.format(date, &quot;yyyy-MM-dd HH:mm:ss&quot;));// 大写的HH是24小时制

        // DateUtils ---加减指定的天数(也可以加减秒、小时等操作)
        Date addDays = DateUtils.addDays(date, 2);
        System.out.println(DateFormatUtils.format(addDays, &quot;yyyy-MM-dd HH:mm:ss&quot;));
        Date addDays2 = DateUtils.addDays(date, -2);
        System.out.println(DateFormatUtils.format(addDays2, &quot;yyyy-MM-dd HH:mm:ss&quot;));

        // 原生日期判断日期先后顺序
        System.out.println(addDays2.after(addDays));
        System.out.println(addDays2.before(addDays));

        // DateUtils---字符串转date
        String strDate = &quot;2018-11-01 19:23:44&quot;;
        try {
            Date parseDateStrictly = DateUtils.parseDateStrictly(strDate, &quot;yyyy-MM-dd HH:mm:ss&quot;);
            Date parseDate = DateUtils.parseDate(strDate, &quot;yyyy-MM-dd HH:mm:ss&quot;);
            System.out.println(parseDateStrictly);
            System.out.println(parseDate);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h4 id="7-StopWatch提供秒表的计时-暂停等功能"><a href="#7-StopWatch提供秒表的计时-暂停等功能" class="headerlink" title="7.StopWatch提供秒表的计时,暂停等功能"></a>7.StopWatch提供秒表的计时,暂停等功能</h4><pre><code>package cn.xm.exam.test;

import org.apache.commons.lang.time.StopWatch;

public class test implements AInterface, BInterface {
    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        try {
            Thread.sleep(5 * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        stopWatch.stop();
        System.out.println(stopWatch.getStartTime());// 获取开始时间
        System.out.println(stopWatch.getTime());// 获取总的执行时间--单位是毫秒
    }
}
</code></pre><h4 id="8-以Range结尾的类主要提供一些范围的操作-包括判断某些字符-数字等是否在这个范围以内"><a href="#8-以Range结尾的类主要提供一些范围的操作-包括判断某些字符-数字等是否在这个范围以内" class="headerlink" title="8.以Range结尾的类主要提供一些范围的操作,包括判断某些字符,数字等是否在这个范围以内"></a>8.以Range结尾的类主要提供一些范围的操作,包括判断某些字符,数字等是否在这个范围以内</h4><pre><code>        IntRange intRange = new IntRange(1, 5);
        System.out.println(intRange.getMaximumInteger());
        System.out.println(intRange.getMinimumInteger());
        System.out.println(intRange.containsInteger(6));
        System.out.println(intRange.containsDouble(3));

结果:

5
1
false
true
</code></pre><h4 id="9-ArrayUtils操作数组，功能强大，可以合并，判断是否包含等操作"><a href="#9-ArrayUtils操作数组，功能强大，可以合并，判断是否包含等操作" class="headerlink" title="9.ArrayUtils操作数组，功能强大，可以合并，判断是否包含等操作"></a>9.ArrayUtils操作数组，功能强大，可以合并，判断是否包含等操作</h4><pre><code>package cn.xm.exam.test;

import org.apache.commons.lang.ArrayUtils;

public class test implements AInterface, BInterface {
    public static void main(String[] args) {
        int array[] = { 1, 5, 5, 7 };
        System.out.println(array);

        // 增加元素
        array = ArrayUtils.add(array, 9);
        System.out.println(ArrayUtils.toString(array));

        // 删除元素
        array = ArrayUtils.remove(array, 3);
        System.out.println(ArrayUtils.toString(array));

        // 反转数组
        ArrayUtils.reverse(array);
        System.out.println(ArrayUtils.toString(array));

        // 查询数组索引
        System.out.println(ArrayUtils.indexOf(array, 5));

        // 判断数组中是否包含指定值
        System.out.println(ArrayUtils.contains(array, 5));

        // 合并数组
        array = ArrayUtils.addAll(array, new int[] { 1, 5, 6 });
        System.out.println(ArrayUtils.toString(array));
    }
}
</code></pre><h4 id="8-反射工具类的使用"><a href="#8-反射工具类的使用" class="headerlink" title="8.  反射工具类的使用"></a>8.  反射工具类的使用</h4><p>一个普通的java:</p>
<pre><code>package cn.xm.exam.test.p1;

public class Person {
    private String name;

    public static void staticMet(String t) {
        System.out.println(t);
    }

    public Person(String name) {
        this.name = name;
    }

    public String call(String string) {
        System.out.println(name);
        System.out.println(string);
        return string;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;test [name=&quot; + name + &quot;]&quot;;
    }
}
</code></pre><p>反射工具类操作:</p>
<pre><code>package cn.xm.exam.test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.apache.commons.lang.reflect.ConstructorUtils;
import org.apache.commons.lang.reflect.FieldUtils;
import org.apache.commons.lang.reflect.MethodUtils;

import cn.xm.exam.test.p1.Person;

public class test {

    public static void main(String[] args) throws InstantiationException, IllegalAccessException,
            IllegalArgumentException, InvocationTargetException, NoSuchMethodException {
        // ConstructorUtils工具类的使用
        Constructor accessibleConstructor = ConstructorUtils.getAccessibleConstructor(Person.class, String.class);
        Person newInstance = (Person) accessibleConstructor.newInstance(&quot;test&quot;);
        System.out.println(newInstance.getClass());
        System.out.println(newInstance);

        // MethodUtils的使用
        Method accessibleMethod = MethodUtils.getAccessibleMethod(Person.class, &quot;call&quot;, String.class);
        Object invoke = accessibleMethod.invoke(newInstance, &quot;参数&quot;);
        System.out.println(invoke);
        // 调用静态方法
        MethodUtils.invokeStaticMethod(Person.class, &quot;staticMet&quot;, &quot;静态方法&quot;);

        // FieldUtils 暴力获取私有变量(第三个参数表示是否强制获取)---反射方法修改元素的值
        Field field = FieldUtils.getField(Person.class, &quot;name&quot;, true);
        field.setAccessible(true);
        System.out.println(field.getType());
        field.set(newInstance, &quot;修改后的值&quot;);
        System.out.println(newInstance.getName());
    }
}



结果:

class cn.xm.exam.test.p1.Person
test [name=test]
test
参数
参数
静态方法
class java.lang.String
修改后的值
</code></pre><h4 id="9-EqualsBuilder-可以用于拼接多个条件进行equals比较"><a href="#9-EqualsBuilder-可以用于拼接多个条件进行equals比较" class="headerlink" title="9.  EqualsBuilder 可以用于拼接多个条件进行equals比较"></a>9.  EqualsBuilder 可以用于拼接多个条件进行equals比较</h4><pre><code>EqualsBuilder equalsBuilder = new EqualsBuilder();
        Integer integer1 = new Integer(1);
        Integer integer2 = new Integer(1);

        String string1 = &quot;111&quot;;
        String string2 = &quot;111&quot;;
        equalsBuilder.append(integer1, integer2);
        equalsBuilder.append(string1, string2);
        System.out.println(equalsBuilder.isEquals());
</code></pre><p>结果:</p>
<p>true</p>
<h4 id="下面是commons-collections包中的常用的工具类"><a href="#下面是commons-collections包中的常用的工具类" class="headerlink" title="========下面是commons-collections包中的常用的工具类=="></a>========下面是commons-collections包中的常用的工具类==</h4><h4 id="1-CollectionUtils工具类用于操作集合-isEmpty-方法最有用-（commons-collections包中的类）"><a href="#1-CollectionUtils工具类用于操作集合-isEmpty-方法最有用-（commons-collections包中的类）" class="headerlink" title="1. CollectionUtils工具类用于操作集合,  isEmpty () 方法最有用   （commons-collections包中的类）"></a>1. CollectionUtils工具类用于操作集合,  isEmpty () 方法最有用   （commons-collections包中的类）</h4><pre><code>package cn.xm.exam.test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.commons.collections.CollectionUtils;

public class test {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;str1&quot;);
        list.add(&quot;str2&quot;);

        List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();
        list1.add(&quot;str1&quot;);
        list1.add(&quot;str21&quot;);

        // 判断是否有任何一个相同的元素
        System.out.println(CollectionUtils.containsAny(list, list1));

        // 求并集(自动去重)
        List&lt;String&gt; list3 = (List&lt;String&gt;) CollectionUtils.union(list, list1);
        System.out.println(list3);

        // 求交集(两个集合中都有的元素)
        Collection intersection = CollectionUtils.intersection(list, list1);
        System.out.println(&quot;intersection-&gt;&quot; + intersection);

        // 求差集(并集去掉交集，也就是list中有list1中没有，list1中有list中没有)
        Collection intersection1 = CollectionUtils.disjunction(list, list1);
        System.out.println(&quot;intersection1-&gt;&quot; + intersection1);

        // 获取一个同步的集合
        Collection synchronizedCollection = CollectionUtils.synchronizedCollection(list);

        // 验证集合是否为null或者集合的大小是否为0，同理有isNouEmpty方法
        List list4 = null;
        List list5 = new ArrayList&lt;&gt;();
        System.out.println(CollectionUtils.isEmpty(list4));
        System.out.println(CollectionUtils.isEmpty(list5));
    }
}
</code></pre><h4 id="2-MapUtils工具类"><a href="#2-MapUtils工具类" class="headerlink" title="2.   MapUtils工具类"></a>2.   MapUtils工具类</h4><p>可以用于map判断null和size为0，也可以直接获取map中的值为指定类型，没有的返回null</p>
<pre><code>package cn.xm.exam.test;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.NumberUtils;

import ognl.MapElementsAccessor;

public class test {
    public static void main(String[] args) {
        Map map = null;
        Map map2 = new HashMap();
        Map map3 = new HashMap&lt;&gt;();
        map3.put(&quot;xxx&quot;, &quot;xxx&quot;);
        // 检验为empty可以验证null和size为0的情况
        System.out.println(MapUtils.isEmpty(map));
        System.out.println(MapUtils.isEmpty(map2));
        System.out.println(MapUtils.isEmpty(map3));

        String string = MapUtils.getString(map3, &quot;eee&quot;);
        String string2 = MapUtils.getString(map3, &quot;xxx&quot;);
        Integer integer = MapUtils.getInteger(map3, &quot;xxx&quot;);
        System.out.println(&quot;string-&gt;&quot; + string);
        System.out.println(&quot;string2-&gt;&quot; + string2);
        System.out.println(&quot;integer-&gt;&quot; + integer);
        System.out.println(integer == null);
    }
}
</code></pre><p>结果:</p>
<pre><code>true
true
false
INFO: Exception: java.text.ParseException: Unparseable number: &quot;xxx&quot;
string-&gt;null
string2-&gt;xxx
integer-&gt;null
true
</code></pre><p>补充:MapUtils也可以获取值作为String，获取不到取默认值:</p>
<pre><code>//获取字符串,如果获取不到可以返回一个默认值
String string3 = MapUtils.getString(map3, &quot;eee&quot;,&quot;没有值&quot;);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/06/14/commons-lang3-3.2.jar中的常用工具类的使用/" data-id="cjy9xsodu000cr4v8z4vvmpsk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Jackson相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/06/Jackson相关/" class="article-date">
  <time datetime="2019-06-06T13:17:12.724Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/06/Jackson相关/">jackson 相关认识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="spring是如何将string-通过jackson变成java对象的"><a href="#spring是如何将string-通过jackson变成java对象的" class="headerlink" title="spring是如何将string 通过jackson变成java对象的"></a>spring是如何将string 通过jackson变成java对象的</h3><p>Spring Boot支持与三种JSON mapping库集成：Gson、Jackson和JSON-B。Jackson是首选和默认的。</p>
<p>Jackson是spring-boot-starter-json的一部分，spring-boot-starter-web中包含spring-boot-starter-json。也就是说，当项目中引入spring-boot-starter-web后会自动引入spring-boot-starter-json。</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre><p>ObjectMapper是jackson-databind包中的一个类，提供读写JSON的功能，可以方便的进行对象和JSON转换：</p>
<pre><code>import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public final class JsonUtil {
    private static ObjectMapper mapper = new ObjectMapper();

    private JsonUtil() {
    }

    /**
     * Serialize any Java value as a String.
     */
    public static String generate(Object object) throws JsonProcessingException {
        return mapper.writeValueAsString(object);
    }

    /**
     * Deserialize JSON content from given JSON content String.
     */
    public static &lt;T&gt; T parse(String content, Class&lt;T&gt; valueType) throws IOException {
        return mapper.readValue(content, valueType);
    }
}    
</code></pre><p>编写一简单POJO测试类：</p>
<pre><code>import java.util.Date;

public class Hero {

    public static void main(String[] args) throws Exception {
        System.out.println(JsonUtil.generate(new Hero(&quot;Jason&quot;, new Date())));
    }

    private String name;

    private Date birthday;

    public Hero() {
    }

    public Hero(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public Date getBirthday() {
        return birthday;
    }
} 
</code></pre><p>运行后输出结果如下：</p>
<pre><code>{&quot;name&quot;:&quot;Jason&quot;,&quot;birthday&quot;:1540909420353}    
</code></pre><h4 id="关于使用Feign的feign-master包中通过feign-jackson-JacksonEncoder、feign-jackson-JacksonDecoder类基于jackson进行加密解密"><a href="#关于使用Feign的feign-master包中通过feign-jackson-JacksonEncoder、feign-jackson-JacksonDecoder类基于jackson进行加密解密" class="headerlink" title="关于使用Feign的feign-master包中通过feign.jackson.JacksonEncoder、feign.jackson.JacksonDecoder类基于jackson进行加密解密"></a>关于使用Feign的feign-master包中通过feign.jackson.JacksonEncoder、feign.jackson.JacksonDecoder类基于jackson进行加密解密</h4><p>源码说明</p>
<pre><code>1.JacksonEncoder加密类

    package feign.jackson;

    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.JavaType;
    import com.fasterxml.jackson.databind.Module;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import com.fasterxml.jackson.databind.SerializationFeature;

    import java.lang.reflect.Type;
    import java.util.Collections;

    import feign.RequestTemplate;
    import feign.codec.EncodeException;
    import feign.codec.Encoder;

    public class JacksonEncoder implements Encoder {

      private final ObjectMapper mapper;

      public JacksonEncoder() {
        this(Collections.&lt;Module&gt;emptyList());
      }

      public JacksonEncoder(Iterable&lt;Module&gt; modules) {
        this(new ObjectMapper()
                 .setSerializationInclusion(JsonInclude.Include.NON_NULL)
                 .configure(SerializationFeature.INDENT_OUTPUT, true)
                 .registerModules(modules));
      }

      public JacksonEncoder(ObjectMapper mapper) {
        this.mapper = mapper;
      }

      @Override
      public void encode(Object object, Type bodyType, RequestTemplate template) {
        try {
          JavaType javaType = mapper.getTypeFactory().constructType(bodyType);
          template.body(mapper.writerFor(javaType).writeValueAsString(object));
        } catch (JsonProcessingException e) {
          throw new EncodeException(e.getMessage(), e);
        }
      }
    }
</code></pre><p>2.JacksonDecoder解密类</p>
<pre><code>package feign.jackson;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.RuntimeJsonMappingException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.Collections;

import feign.Response;
import feign.Util;
import feign.codec.Decoder;

public class JacksonDecoder implements Decoder {

  private final ObjectMapper mapper;

  public JacksonDecoder() {
    this(Collections.&lt;Module&gt;emptyList());
  }

  public JacksonDecoder(Iterable&lt;Module&gt; modules) {
    this(new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
             .registerModules(modules));
  }

  public JacksonDecoder(ObjectMapper mapper) {
    this.mapper = mapper;
  }

  @Override
  public Object decode(Response response, Type type) throws IOException {
    if (response.status() == 404) return Util.emptyValueOf(type);
    if (response.body() == null) return null;
    Reader reader = response.body().asReader();
    if (!reader.markSupported()) {
      reader = new BufferedReader(reader, 1);
    }
    try {
      // Read the first byte to see if we have any data
      reader.mark(1);
      if (reader.read() == -1) {
        return null; // Eagerly returning null avoids &quot;No content to map due to end-of-input&quot;
      }
      reader.reset();
      return mapper.readValue(reader, mapper.constructType(type));
    } catch (RuntimeJsonMappingException e) {
      if (e.getCause() != null &amp;&amp; e.getCause() instanceof IOException) {
        throw IOException.class.cast(e.getCause());
      }
      throw e;
    }
  }
} 
</code></pre><h4 id="ObjectMapper-是线程安全的吗？"><a href="#ObjectMapper-是线程安全的吗？" class="headerlink" title="ObjectMapper 是线程安全的吗？"></a>ObjectMapper 是线程安全的吗？</h4><p>是的，官方注释中这样回应的：</p>
<pre><code>Is ObjectMapper thread-safe? Short answer: yes Long answer: yes, as long as you always configure instance before use, and do not call configure 
methods during operation (or synchronize such calls appropriately). Usually it is better to construct separate mapper instance if configurations differ in any case.   
</code></pre><h4 id="为什么spring可以正确解析-application-jason-application-form-等"><a href="#为什么spring可以正确解析-application-jason-application-form-等" class="headerlink" title="为什么spring可以正确解析 application/jason  application/form 等"></a>为什么spring可以正确解析 application/jason  application/form 等</h4><p>@RequestBody</p>
<p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p>
<p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p>
<p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里</p>
<p>@RestController中有@ResponseBody，可以帮我们把对象列化到resp.body中。@RequestBody可以帮我们把req.body的内容转化为对象。如果是开发Web应用，一般<br>这两个注解对应的就是Json序列化和反序列化的操作。这里实际上已经体现了Http序列化/反序列化这个过程，只不过和普通的对象序列化有些不一样，Http序列化/反序<br>列化的层次更高，属于一种Object2Object之间的转换。<br>Http序列化和反序列化的核心是HttpMessageConverter。用过老版本springmvc的可能有些印象，那时候需要在xml配置文件中注入MappingJackson2HttpMessageConverter<br>这个类型的bean，告诉springmvc我们需要进行Json格式的转换，它就是HttpMessageConverter的一种实现。</p>
<h4 id="spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成-fastjson"><a href="#spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成-fastjson" class="headerlink" title="spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成 fastjson"></a>spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成 fastjson</h4><p>Spring Boot支持与三种JSON mapping库集成：Gson、Jackson和JSON-B。Jackson是首选和默认的。<br>如果使用fastjson，可以按照下列方式配置使用</p>
<p>引入fastjson依赖库</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.46&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

compile(&quot;com.alibaba:fastjson:${fastJsonVersion}&quot;)
ext {
        fastJsonVersion    = &apos;1.2.46&apos;
    }
</code></pre><p>注： 这里要说下很重要的话，官方文档说的1.2.10以后，会有两个方法支持HttpMessageconvert，一个是FastJsonHttpMessageConverter，支持4.2以下的版本，<br>        一个是FastJsonHttpMessageConverter4支持4.2以上的版本，具体有什么区别暂时没有深入研究。这里也就是说：低版本的就不支持了，所以这里最低要求就是1.2.10+</p>
<p>在启动类中配置</p>
<p>配置方式一（通过继承的方式）</p>
<p>　　1、启动类继承WebMvcConfigurerAdapter<br>　　2、重写configureMessageConverters方法</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableScheduling
public class MemberApplication extends WebMvcConfigurerAdapter {
    /**
     * 配置FastJson为方式一
     * @return*/
    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        super.configureMessageConverters(converters);
        /*
         * 1、需要先定义一个convert转换消息的对象 2、添加fastJson的配置信息，比如：是否要格式化返回json数据 3、在convert中添加配置信息
         * 4、将convert添加到converters当中
         * 
         */
        // 1、需要先定义一个·convert转换消息的对象；
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2、添加fastjson的配置信息，比如 是否要格式化返回json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3、在convert中添加配置信息.
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4、将convert添加到converters当中.
        converters.add(fastConverter);
    }

    public static void main(String[] args) {
        SpringApplication.run(MemberApplication.class, args);
    }

}
</code></pre><p>注：开发中为了统一管理配置，可以放入配置类中，启动类只做启动的功能</p>
<pre><code>@Configuration
public class HttpConverterConfig {

    @Bean
    public HttpMessageConverters fastJsonHttpMessageConverters() {
        // 1.定义一个converters转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3.在converter中添加配置信息
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4.将converter赋值给HttpMessageConverter
        HttpMessageConverter&lt;?&gt; converter = fastConverter;
        // 5.返回HttpMessageConverters对象
        return new HttpMessageConverters(converter);
    }
}
</code></pre><p>配置方式二（通过@Bean注入的方式）<br>在App.java启动类中，注入Bean : HttpMessageConverters</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableScheduling
public class MemberApplication {
    /**
     * 配置FastJson方式二
     * @return  HttpMessageConverters
     */
    @Bean
    public HttpMessageConverters fastJsonHttpMessageConverters() {
        // 1.定义一个converters转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3.在converter中添加配置信息
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4.将converter赋值给HttpMessageConverter
        HttpMessageConverter&lt;?&gt; converter = fastConverter;
        // 5.返回HttpMessageConverters对象
        return new HttpMessageConverters(converter);
    }

    public static void main(String[] args) {
        SpringApplication.run(MemberApplication.class, args);
    }

}
</code></pre><p>在pojo类中：</p>
<pre><code>private int id;
private String name;

//com.alibaba.fastjson.annotation.JSONField
@JSONField(format=&quot;yyyy-MM-dd HH:mm&quot;)
private Date createTime;//创建时间.

/*
 * serialize:是否需要序列化属性.
 */
@JSONField(serialize=false)
private String remarks;//备注信息.
</code></pre><p>那么这时候在实体类中使用@JSONField(serialize=false)，是不是此字段就不返回了，如果是的话，那么就配置成功了，其中JSONField的包路径是：com.alibaba.fastjson.annotation.JSONField。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/06/06/Jackson相关/" data-id="cjy9xsodg0009r4v8zyn0f9ew" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/31/代理模式/" class="article-date">
  <time datetime="2019-05-31T11:58:01.357Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/31/代理模式/">代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###如何理解代理模式？<br>思考抽象问题最好的办法就是具体化！</p>
<p>比如我们需要为一个业务方法在执行前后记录日志，为了达到解耦的目的，我们可以再新建一个类并定义一个新的业务方法，该方法既可以调用原业务方法，又可以在调用前后进行日志处理，例如：</p>
<pre><code>CarProxy.class

public void move() {
    System.out.println(&quot;日志开始记录....&quot;);
    new Car().move();
    System.out.println(&quot;日志记录完成....&quot;);
}
</code></pre><p>代理模式的应用很多，比如Spring容器的延迟加载，AOP增强处理等。</p>
<p>####一：静态代理</p>
<pre><code>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。

所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
</code></pre><p>一句话，自己手写代理类就是静态代理。</p>
<p>####基于继承的静态代理</p>
<p>目标对象：定义一个普通方法<br>    public class Car {</p>
<pre><code>    public void move() {
        System.out.println(&quot;1.汽车开始跑步&quot;);
        System.out.println(&quot;2.汽车跑到了终点&quot;);
    }

}
</code></pre><p>代理对象：主要作用是继承目标对象，进行增强处理，并使用关键字super调用父类方法。</p>
<pre><code>public class CarProxy extends Car {

    @Override
    public void move() {
        System.out.println(&quot;日志开始记录....&quot;);
        super.move();
        System.out.println(&quot;日志记录完成....&quot;);
    }

}
</code></pre><p>测试方法：实际上是调用代理对象的move()方法。</p>
<pre><code>public static void main(String[] args) {
        Car car = new CarProxy();
        car.move();
    }
</code></pre><p>####基于接口的静态代理</p>
<p>共同接口：定义一个普通的接口方法</p>
<pre><code>public interface Moveable {
    void move();
}
</code></pre><p>目标对象：实现该接口方法。</p>
<pre><code>public class Car implements Moveable {

    @Override
    public void move() {
        System.out.println(&quot;汽车行驶中....&quot;);
    }

}
</code></pre><p>代理对象：调用目标对象的方法，并在调用前后进行增强处理。</p>
<pre><code>public class CarProxy implements Moveable{
    private Moveable move;

    @Override
    public void move() {
        if(move==null){
            move = new Car();
        }
        System.out.println(&quot;开始记录日志：&quot;);
        move.move();
        System.out.println(&quot;记录日志结束！&quot;);

    }
}
</code></pre><p>测试方法：实际上是调用代理对象的move()方法。</p>
<pre><code>public static void main(String[] args) throws Exception {
    Moveable m =new CarProxy();
    m.move();
}
</code></pre><p>###静态代理的优缺点</p>
<p>#####优点：</p>
<p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理模式的共有优点。</p>
<p>#####缺点：</p>
<p>1）代理对象的一个接口只服务于一种类型的对象，如果要代理的类型很多，势必要为每一种类型的方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</p>
<p>   比如Car类的move()方法需要记录日志，如果还有汽车，火车，自行车类的move()方法也需要记录日志，我们都要一个个的去为它们生成代理类，太麻烦了。</p>
<p>2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。显而易见，增加了代码维护的复杂度。 </p>
<p>###二：动态代理</p>
<pre><code>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。

动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成 。
</code></pre><p>简单来说，动态代理就是交给程序去自动生成代理类。</p>
<p>###JDK的动态代理</p>
<p>JDK动态代理实现步骤：</p>
<pre><code>创建被代理的类以及实现的接口；
创建一个实现接口InvocationHandler的类，它必须实现invoke方法；
调用Proxy的newProxyInstance静态方法，创建一个代理类。
通过代理对象调用目标方法。
</code></pre><p>####代码示例</p>
<p>共同接口        </p>
<pre><code>public interface Moveable {
    String move();
}
</code></pre><p>目标对象：正常实现接口方法</p>
<pre><code>public class Car implements Moveable {

    @Override
    public String move() {
        return &quot;汽车行驶中&quot;;
    }

}    
</code></pre><p>对目标对象的增强处理：</p>
<pre><code>public class LogHandler implements InvocationHandler{
    private Object target;

    public LogHandler(Object object){
        super();
        this.target =  object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //增强处理
        Object o = method.invoke(target,args);
        //增强处理
        return o;
    }

}
</code></pre><p>实现InvocationHandler接口步骤：</p>
<pre><code>定义含参构造方法，该参数为要代理的实例对象，目的是用于执行method.invoke()方法（也就是执行目标方法）

实现接口的invoke()方法，该方法用于对目标方法的增强处理，比如记录日志等。该方法的返回值就是代理对象执行目标方法的返回值。具体参数：

proxy 动态生成的代理对象

method 目标方法的实例

args 目标方法的参数
</code></pre><p>测试方法：</p>
<pre><code>public static void main(String[] args) {
    Moveable move =  (Moveable) Proxy.newProxyInstance(Car.class.getClassLoader(), Car.class.getInterfaces(), new LogHandler(new Car()));

    System.out.println(&quot;代理对象:&quot;+move.getClass().getName());
    System.out.println(&quot;执行方法:&quot;+move.move());
}
</code></pre><p>通过调用Proxy.newProxyInstance方法生成代理对象，具体参数有：</p>
<pre><code>loader 目标类的类加载器
interfaces 目标类实现的接口
InvocationHandler 调用处理程序的实现对象
</code></pre><p>打印结果</p>
<pre><code>代理对象:com.sun.proxy.$Proxy0
执行方法:汽车行驶中
</code></pre><p>值得一提的是，JDK动态代理针对每个代理对象都会有一个关联的调用处理程序，即实现InvocationHandler接口。当在代理对象上调用目标方法时，将对方法调用进行编码并将其分配给其实现 InvocationHandler 接口的 invoke 方法。</p>
<p>####特点</p>
<p>JDK的动态代理只能代理实现了接口的类， 没有实现接口的类不能实现动态代理</p>
<p>###cglib的动态代理</p>
<p>引用cglib的依赖包</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>执行步骤按顺序写下</p>
<pre><code>public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        //设置父类，被代理类（这里是Car.class）
        enhancer.setSuperclass(Car.class);
        //设置回调函数
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                //增强处理...
                Object o= proxy.invokeSuper(obj, args);//代理类调用父类的方法
                //增强处理...
                return o;
            }
        });
        //创建代理类并使用回调（用父类Car去引用）
        Car car = (Car) enhancer.create();
        //执行目标方法
        System.out.println(car.move());
    }
</code></pre><p>####方法拦截器</p>
<p>实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法。</p>
<p>intercept方法的具体参数有</p>
<pre><code>obj 目标类的实例
method 目标方法实例（通过反射获取的目标方法实例）
args 目标方法的参数
proxy 代理类的实例
</code></pre><p>该方法的返回值就是目标方法的返回值。</p>
<p>####特点</p>
<pre><code>cglib的动态代理是针对类来实现代理。
对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。
因为是通过继承实现，final类无法使用。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/31/代理模式/" data-id="cjy9xsodh000ar4v8nzcl04a8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Jackson快速入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/24/Jackson快速入门/" class="article-date">
  <time datetime="2019-05-24T11:05:30.819Z" itemprop="datePublished">2019-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/24/Jackson快速入门/">jackson 快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。</p>
<p>###引入类库</p>
<pre><code>ext {
    jacksonVersion = &apos;2.9.5&apos;
}

dependencies {
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-core&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-databind&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-annotations&apos;, version: jacksonVersion
    // 引入XML功能
    compile group: &apos;com.fasterxml.jackson.dataformat&apos;, name: &apos;jackson-dataformat-xml&apos;, version: jacksonVersion
    // 比JDK自带XML实现更高效的类库
    compile group: &apos;com.fasterxml.woodstox&apos;, name: &apos;woodstox-core&apos;, version: &apos;5.1.0&apos;
    // Java 8 新功能
    compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jsr310&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.module&apos;, name: &apos;jackson-module-parameter-names&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jdk8&apos;, version: jacksonVersion

    compileOnly group: &apos;org.projectlombok&apos;, name: &apos;lombok&apos;, version: &apos;1.16.22&apos;
}
</code></pre><p>###属性命名<br>@JsonProperty注解指定一个属性用于JSON映射，默认情况下映射的JSON属性与注解的属性名称相同，不过可以使用该注解的value值修改JSON属性名，该注解还有一个index属性指定生成JSON属性的顺序，如果有必要的话。</p>
<p>###属性包含<br>还有一些注解可以管理在映射JSON的时候包含或排除某些属性，下面介绍一下常用的几个。</p>
<p>@JsonIgnore注解用于排除某个属性，这样该属性就不会被Jackson序列化和反序列化。</p>
<p>@JsonIgnoreProperties注解是类注解。在序列化为JSON的时候，@JsonIgnoreProperties({“prop1”, “prop2”})会忽略pro1和pro2两个属性。在从JSON反序列化为Java类的时候，@JsonIgnoreProperties(ignoreUnknown=true)会忽略所有没有Getter和Setter的属性。该注解在Java类和JSON不完全匹配的时候很有用。</p>
<p>@JsonIgnoreType也是类注解，会排除所有指定类型的属性。</p>
<p>###序列化相关<br>@JsonPropertyOrder和@JsonProperty的index属性类似，指定属性序列化时的顺序。</p>
<p>@JsonRootName注解用于指定JSON根属性的名称。</p>
<p>###处理JSON</p>
<p>###简单映射<br>我们用Lombok设置一个简单的Java类。</p>
<pre><code>@Data
@AllArgsConstructor
@NoArgsConstructor
public class Friend {
    private String nickname;
    private int age;
}
</code></pre><p>然后就可以处理JSON数据了。首先需要一个ObjectMapper对象，序列化和反序列化都需要它。</p>
<pre><code>ObjectMapper mapper = new ObjectMapper();
Friend friend = new Friend(&quot;yitian&quot;, 25);

// 写为字符串
String text = mapper.writeValueAsString(friend);
// 写为文件
mapper.writeValue(new File(&quot;friend.json&quot;), friend);
// 写为字节流
byte[] bytes = mapper.writeValueAsBytes(friend);
System.out.println(text);
// 从字符串中读取
Friend newFriend = mapper.readValue(text, Friend.class);
// 从字节流中读取
newFriend = mapper.readValue(bytes, Friend.class);
// 从文件中读取
newFriend = mapper.readValue(new File(&quot;friend.json&quot;), Friend.class);
System.out.println(newFriend);
</code></pre><p>程序结果如下。可以看到生成的JSON属性和Java类中定义的一致。</p>
<pre><code>{&quot;nickname&quot;:&quot;yitian&quot;,&quot;age&quot;:25}
Friend(nickname=yitian, age=25)
</code></pre><p>###集合的映射</p>
<p>除了使用Java类进行映射之外，我们还可以直接使用Map和List等Java集合组织JSON数据，在需要的时候可以使用readTree方法直接读取JSON中的某个属性值。需要注意的是从JSON转换为Map对象的时候，由于Java的类型擦除，所以类型需要我们手动用new TypeReference<t>给出。</t></p>
<pre><code>ObjectMapper mapper = new ObjectMapper();

Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;age&quot;, 25);
map.put(&quot;name&quot;, &quot;yitian&quot;);
map.put(&quot;interests&quot;, new String[]{&quot;pc games&quot;, &quot;music&quot;});

String text = mapper.writeValueAsString(map);
System.out.println(text);

Map&lt;String, Object&gt; map2 = mapper.readValue(text, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {
});
System.out.println(map2);

JsonNode root = mapper.readTree(text);
String name = root.get(&quot;name&quot;).asText();
int age = root.get(&quot;age&quot;).asInt();

System.out.println(&quot;name:&quot; + name + &quot; age:&quot; + age);
</code></pre><p>程序结果如下。</p>
<pre><code>{&quot;name&quot;:&quot;yitian&quot;,&quot;interests&quot;:[&quot;pc games&quot;,&quot;music&quot;],&quot;age&quot;:25}
{name=yitian, interests=[pc games, music], age=25}
name:yitian age:25
</code></pre><p>###Jackson配置</p>
<p>Jackson预定义了一些配置，我们通过启用和禁用某些属性可以修改Jackson运行的某些行为。详细文档参考JacksonFeatures。下面我简单翻译一下Jackson README上列出的一些属性。</p>
<pre><code>// 美化输出
mapper.enable(SerializationFeature.INDENT_OUTPUT);
// 允许序列化空的POJO类
// （否则会抛出异常）
mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
// 把java.util.Date, Calendar输出为数字（时间戳）
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

// 在遇到未知属性的时候不抛出异常
mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
// 强制JSON 空字符串(&quot;&quot;)转换为null对象值:
mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);

// 在JSON中允许C/C++ 样式的注释(非标准，默认禁用)
mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
// 允许没有引号的字段名（非标准）
mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
// 允许单引号（非标准）
mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
// 强制转义非ASCII字符
mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);
// 将内容包裹为一个JSON属性，属性名由@JsonRootName注解指定
mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);
</code></pre><p>这里有三个方法，configure方法接受配置名和要设置的值，Jackson 2.5版本新加的enable和disable方法则直接启用和禁用相应属性，推荐使用后面两个方法。</p>
<p>###用注解管理映射</p>
<p>前面介绍了一些Jackson注解，下面来应用一下这些注解。首先来看看使用了注解的Java类。</p>
<pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonRootName(&quot;FriendDetail&quot;)
@JsonIgnoreProperties({&quot;uselessProp1&quot;, &quot;uselessProp3&quot;})
public class FriendDetail {
    @JsonProperty(&quot;NickName&quot;)
    private String name;
    @JsonProperty(&quot;Age&quot;)
    private int age;
    private String uselessProp1;
    @JsonIgnore
    private int uselessProp2;
    private String uselessProp3;
}
</code></pre><p>然后看看代码。需要注意的是，由于设置了排除的属性，所以生成的JSON和Java类并不是完全对应关系，所以禁用DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES是必要的。</p>
<pre><code>ObjectMapper mapper = new ObjectMapper();
//mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
FriendDetail fd = new FriendDetail(&quot;yitian&quot;, 25, &quot;&quot;, 0, &quot;&quot;);
String text = mapper.writeValueAsString(fd);
System.out.println(text);

FriendDetail fd2 = mapper.readValue(text, FriendDetail.class);
System.out.println(fd2);
</code></pre><p>运行结果如下。可以看到生成JSON的时候忽略了我们制定的值，而且在转换为Java类的时候对应的属性为空。</p>
<pre><code>{&quot;NickName&quot;:&quot;yitian&quot;,&quot;Age&quot;:25}
FriendDetail(name=yitian, age=25, uselessProp1=null, uselessProp2=0, uselessProp3=null)
</code></pre><p>##处理XML</p>
<p>Jackson是一个处理JSON的类库，不过它也通过jackson-dataformat-xml包提供了处理XML的功能。Jackson建议我们在处理XML的时候使用woodstox-core包，它是一个XML的实现，比JDK自带XML实现更加高效，也更加安全。</p>
<p>这里有个注意事项，如果你正在使用Java 9以上的JDK，可能会出现java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException异常，这是因为Java 9实现了JDK的模块化，将原本和JDK打包在一起的JAXB实现分隔出来。所以这时候需要我们手动添加JAXB的实现。在Gradle中添加下面的代码即可。</p>
<pre><code>compile group: &apos;javax.xml.bind&apos;, name: &apos;jaxb-api&apos;, version: &apos;2.3.0&apos;
</code></pre><p>###注解</p>
<p>Jackson XML除了使用Jackson JSON和JDK JAXB的一些注解之外，自己也定义了一些注解。下面简单介绍一下几个常用注解。</p>
<p>@JacksonXmlProperty注解有三个属性，namespace和localname属性用于指定XML命名空间的名称，isAttribute指定该属性作为XML的属性（）还是作为子标签（）.</p>
<p>@JacksonXmlRootElement注解有两个属性，namespace和localname属性用于指定XML根元素命名空间的名称。</p>
<p>@JacksonXmlText注解将属性直接作为未被标签包裹的普通文本表现。</p>
<p>@JacksonXmlCData将属性包裹在CDATA标签中。</p>
<p>###XML映射</p>
<p>新建如下一个Java类。</p>
<pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonRootName(&quot;Person&quot;)
public class Person {
    @JsonProperty(&quot;Name&quot;)
    private String name;
    @JsonProperty(&quot;NickName&quot;)
    //@JacksonXmlText
    private String nickname;
    @JsonProperty(&quot;Age&quot;)
    private int age;
    @JsonProperty(&quot;IdentityCode&quot;)
    @JacksonXmlCData
    private String identityCode;
    @JsonProperty(&quot;Birthday&quot;)
    //@JacksonXmlProperty(isAttribute = true)
    @JsonFormat(pattern = &quot;yyyy/MM/DD&quot;)
    private LocalDate birthday;

}
</code></pre><p>下面是代码示例，基本上和JSON的API非常相似，XmlMapper实际上就是ObjectMapper的子类。</p>
<pre><code>Person p1 = new Person(&quot;yitian&quot;, &quot;易天&quot;, 25, &quot;10000&quot;, LocalDate.of(1994, 1, 1));
XmlMapper mapper = new XmlMapper();
mapper.findAndRegisterModules();
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
mapper.enable(SerializationFeature.INDENT_OUTPUT);
String text = mapper.writeValueAsString(p1);
System.out.println(text);

Person p2 = mapper.readValue(text, Person.class);
System.out.println(p2);
</code></pre><p>运行结果如下。</p>
<pre><code>&lt;Person&gt;
  &lt;Name&gt;yitian&lt;/Name&gt;
  &lt;NickName&gt;易天&lt;/NickName&gt;
  &lt;Age&gt;25&lt;/Age&gt;
  &lt;IdentityCode&gt;&lt;![CDATA[10000]]&gt;&lt;/IdentityCode&gt;
  &lt;Birthday&gt;1994/01/01&lt;/Birthday&gt;
&lt;/Person&gt;

Person(name=yitian, nickname=易天, age=25, identityCode=10000, birthday=1994-01-01)
</code></pre><p>如果取消那两行注释，那么运行结果如下。可以看到Jackson XML注解对生成的XML的控制效果。</p>
<pre><code>&lt;Person birthday=&quot;1994/01/01&quot;&gt;
  &lt;Name&gt;yitian&lt;/Name&gt;易天
  &lt;Age&gt;25&lt;/Age&gt;
  &lt;IdentityCode&gt;&lt;![CDATA[10000]]&gt;&lt;/IdentityCode&gt;
&lt;/Person&gt;

Person(name=yitian, nickname=null, age=25, identityCode=10000, birthday=1994-01-01)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/24/Jackson快速入门/" data-id="cjy9xsodf0008r4v89zj3i45a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git回滚远程仓库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/10/git回滚远程仓库/" class="article-date">
  <time datetime="2019-05-10T13:58:55.465Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/10/git回滚远程仓库/">git回滚远程仓库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>使用git管理项目开发的过程中经常会碰到这种情况：某次提交已经push到了远程仓库，可是突然意识到“天哪，我怎么做了这么蠢的事情”。那么问题来了，怎么将远程代码库回滚呢？

在网上看到大部分人给出的解决方案是先将本地回滚，然后删除远程分支，之后再将本地的分支push到远程仓库，这其实是一种很危险的方案，毕竟直接删除远程分支太狠了，不推荐这样做。。。
</code></pre><p>###关于远程仓库回滚</p>
<p>####1、删除最后一次提交<br>这种情况是最简单的了，只需要以下两步就可以了</p>
<pre><code>git revert HEAD
git push origin master
</code></pre><p>注意，revert和reset的区别:</p>
<p>revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在，而reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。如果还没有理解的话，我们做如下测试：<br>假设我们有以下三次提交记录：</p>
<p>log</p>
<p>现在我们使用revert放弃最后一次提交，之后执行git log：</p>
<pre><code>git revert HEAD
git log
</code></pre><p>历史记录中还有第三次提交的记录，并且多了一次的提交，但是仓库内容已经回到了第二次提交之后的状态。 现在我们使用reset回到第三次提交，之后执行git log：</p>
<pre><code>git reset --hard HEAD^
git log
</code></pre><p>历史记录中已经没有之前revert生成的提交记录了，现在应该明白了吧。 如果删除远程仓库的最后一次提交的时候不需要保留历史记录的话，可以使用reset，命令如下：</p>
<pre><code>git reset --hard HEAD^
git push origin master -f
</code></pre><p>-f 参数是强制提交，因为reset之后本地库落后于远程库一个版本，因此需要强制提交。</p>
<p>####2、删除历史某次提交</p>
<p>这种情况需要先用git log命令在历史记录中查找到想要删除的某次提交的commit id，比如下图中圈出来的就是注释为”2”的提交的commit id（由此可见提交的注释很重要，一定要认真写）</p>
<p>然后执行以下命令（”commit id”替换为想要删除的提交的”commit id”，需要注意最后的^号，意思是commit id的前一次提交）：</p>
<pre><code>git rebase -i &quot;commit id&quot;^
</code></pre><p>执行该条命令之后会打开一个编辑框，内容如下，列出了包含该次提交在内之后的所有提交。</p>
<p>然后在编辑框中删除你想要删除的提交所在行，然后保存退出就好啦，如果有冲突的需要解决冲突。接下来，执行以下命令，将本地仓库提交到远程库就完成了：</p>
<pre><code>git push origin master -f     
</code></pre><p>3、修改历史某次提交</p>
<p>这种情况的解决方法类似于第二种情况，只需要在第二条打开编辑框之后，将你想要修改的提交所在行的pick替换成edit然后保存退出，这个时候rebase会停在你要修改的提交，然后做你需要的修改，修改完毕之后，执行以下命令：</p>
<pre><code>git add .
git commit --amend
git rebase --continue
</code></pre><p>如果你在之前的编辑框修改了n行，也就是说要对n次提交做修改，则需要重复执行以上步骤n次。</p>
<p>需要注意的是，在执行rebase命令对指定提交修改或删除之后，该次提交之后的所有提交的”commit id”都会改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/10/git回滚远程仓库/" data-id="cjy9xsod40003r4v8debfpxdw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Java 8 in Action》Chapter 12：新的日期和时间API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/" class="article-date">
  <time datetime="2019-04-30T08:51:23.602Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/">《Java 8 in Action》Chapter 12：新的日期和时间API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。同时这个类还有两个很大的缺点：年份的起始选择是1900年，月份的起始从0开始。</p>
<p>在Java 1.1中，Date类中的很多方法被废弃，取而代之的是java.util.Calendar类。然而Calendar类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</p>
<p>###1. 使用LocalDate 和LocalTime</p>
<p>####1.1 LocalDate<br>  Java 8提供新的日期和时间API,LocalDate类实例是一个不可变对象，只提供简单的日期并且不含当天时间信息。此外也不附带任何与时区相关的信息。<br>  通过静态工厂方法of创建一个LocalDate实例。LocalDate实例提供了多种方法来读取敞亮的值，比如年份、月份、星期几等，如下所示。</p>
<pre><code>LocalDate localDate = LocalDate.of(2014, 3, 18);
int year = localDate.getYear();
Month month = localDate.getMonth();
int day = localDate.getDayOfMonth();
DayOfWeek dow = localDate.getDayOfWeek();
int len = localDate.lengthOfMonth();
boolean leap = localDate.isLeapYear();

// 使用工厂方法从系统时钟中获取当前的日期
LocalDate today = LocalDate.now();

System.out.println(String.format(&quot;year:%s\nmonth:%s\nday:%s\ndow:%s\nlen:%s\nleap:%s&quot;, year, month, day, dow, len, leap));
System.out.println(today);

 结果：
 year:2014  
 month:MARCH  
 day:18  
 dow:TUESDAY  
 len:  
 leap:false  
 2019-03-27  
</code></pre><p>  Java 8日期-时间类都提供了类似的工厂方法。通过传递TemporalField参数给get方法拿到同样的信息。TemporalField接口定义了如何访问temporal对象某个字段的值。ChronoField枚举实现TemporalField接口,可以使用get方法得到枚举元素的值。</p>
<pre><code>int year = localDate.get(ChronoField.YEAR);
int month = localDate.get(ChronoField.MONTH_OF_YEAR);
int day = localDate.get(ChronoField.DAY_OF_MONTH);
</code></pre><p>####1.2 LocalTime</p>
<p>   使用LocalTime类表示时间,可以使用of重载的两个工厂方法创建LocalTime的实例。</p>
<p>   &nbsp;&nbsp;&nbsp;&nbsp;第一个重载函数接收小时和分钟<br>   &nbsp;&nbsp;&nbsp;&nbsp;第二个重载函数同时还接收秒。</p>
<p>   LocalTime类也提供了一些get方法访问这些变量的值，如下所示。</p>
<pre><code>LocalTime localTime = LocalTime.of(13, 45, 20);
int hour = localTime.getHour();
int minute = localTime.getMinute();
int second = localTime.getSecond();
System.out.println(String.format(&quot;hour:%s\nminute:%s\nsecond:%s&quot;, hour, minute, second));

打印结果：
hour:13
minute:45
second:20
</code></pre><p>   LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse可以实现：</p>
<pre><code>LocalDate date = LocalDate.parse(&quot;2019-03-27&quot;);
LocalTime time = LocalTime.parse(&quot;20:17:08&quot;);

//可以向parse方法传递一个DateTimeFormatter。该类的实例定义了如何格式化一个日期或者时间对象。用来替换老版java.util.DateFormat。
//如果传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。
</code></pre><p>###2. 合并日期和时间</p>
<p>   复合类LocalDateTime，是LocalDate和LocalTime的合体。它同时表示了日期和时间，不带有时区信息。可以直接创建，也可以通过合并日期和时间对象构造。</p>
<pre><code>LocalTime time = LocalTime.of(21, 31, 50);
LocalDate date = LocalDate.of(2019, 03, 27);

LocalDateTime dt1 = LocalDateTime.of(2017, Month.NOVEMBER, 07, 22, 31, 51);
LocalDateTime dt2 = LocalDateTime.of(date, time);
LocalDateTime dt3 = date.atTime(22, 21, 14);
LocalDateTime dt4 = date.atTime(time);
LocalDateTime dt5 = time.atDate(date);
</code></pre><p>   创建LocalDateTime对象</p>
<p>   &nbsp;&nbsp;直接创建<br>   &nbsp;&nbsp;通过atTime方法向LocalDate传递一个时间对象<br>   &nbsp;&nbsp;通过atDate方法向LocalTime传递一个时间对象</p>
<p>   也可以使用toLocalDate或者toLocalTime方法，从LocalDateTime中提取LocalDate或者LocalTime组件：</p>
<pre><code>LocalDate date1 = dt1.toLocalDate();
LocalTime time1 = dt1.toLocalTime();
</code></pre><p>###3. 机器的日期和时间格式</p>
<p>   从计算机的角度来看，”2019年03月27日11:20:03”这样的方式是不容易理解的,计算机更加容易理解建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。新的java.time.Instant类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
<p>####3.1 创建Instant </p>
<p>   静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。<br>   静态工厂方法ofEpochSecond还有一个增强的重载版本，它接收第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整。重载的版本会调整纳秒参数，确保保存的纳秒分片在0到999 999999之间。</p>
<pre><code>Instant.ofEpochSecond(3);
Instant.ofEpochSecond(3, 0);
// 2 秒之后再加上100万纳秒（1秒）
Instant.ofEpochSecond(2, 1_000_000_000);
// 4秒之前的100万纳秒（1秒）
Instant.ofEpochSecond(4, -1_000_000_000);
</code></pre><p>####3.2 工厂方法now<br>Instant类也支持静态工厂方法now，它能够获取当前时刻的时间戳。<br>    Instant now = Instant.now();<br>    System.out.println(now);</p>
<pre><code>2019-03-27T03:26:39.451Z
</code></pre><p>Instant的设计初衷是为了便于机器使用,它包含的是由秒及纳秒所构成的数字。因此Instant无法处理那些我们非常容易理解的时间单位。</p>
<pre><code>int day = Instant.now().get(ChronoField.DAY_OF_MONTH);
它会抛出下面这样的异常：

Exception in thread &quot;main&quot; java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth
但是你可以通过Duration和Period类使用Instant，接下来我们会对这部分内容进行介绍。
</code></pre><p>###4. Duration和Period</p>
<p>####4.1 Duration</p>
<p>所有类都实现了Temporal接口，该接口定义如何读取和操纵为时间建模的对象的值。如果需要创建两个Temporal对象之间的duration,就需要Duration类的静态工厂方法between。<br>可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration：</p>
<pre><code>LocalTime time1 = LocalTime.of(21, 50, 10);
LocalTime time2 = LocalTime.of(22, 50, 10);
LocalDateTime dateTime1 = LocalDateTime.of(2019, 03, 27, 21, 20, 40);
LocalDateTime dateTime2 = LocalDateTime.of(2019, 03, 27, 21, 20, 40);
Instant instant1 = Instant.ofEpochSecond(1000 * 60 * 2);
Instant instant2 = Instant.ofEpochSecond(1000 * 60 * 3);

Duration d1 = Duration.between(time1, time2);
Duration d2 = Duration.between(dateTime1, dateTime2);
Duration d3 = Duration.between(instant1, instant2);
// PT1H 相差1小时
System.out.println(&quot;d1:&quot; + d1);
// PT2H 相差2小时
System.out.println(&quot;d2:&quot; + d2);
// PT16H40M 相差16小时40分钟
System.out.println(&quot;d3:&quot; + d3);
</code></pre><p>###4.2 Period</p>
<p>使用Period类以年、月或者日的方式对多个时间单位建模。使用该类的工厂方法between，可以使用得到两个LocalDate之间的时长。</p>
<pre><code>Period period = Period.between(LocalDate.of(2019, 03, 7), LocalDate.of(2019, 03, 17));
// 相差10天
System.out.println(&quot;Period between:&quot; + period);
</code></pre><p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例。</p>
<pre><code>Duration threeMinutes = Duration.ofMinutes(3);
Duration fourMinutes = Duration.of(4, ChronoUnit.MINUTES);

Period tenDay = Period.ofDays(10);
Period threeWeeks = Period.ofWeeks(3);
Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);
Duration类和Period类共享了很多相似的方法，有兴趣的可以参考官网的文档。
</code></pre><p>###5. 操纵、解析和格式化日期<br>如果已经有一个LocalDate对象，想要创建它的一个修改版，最直接也最简单的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。</p>
<pre><code>// 这段代码中所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象！
LocalDate date1 = LocalDate.of(2017, 12, 15);
LocalDate date2 = date1.withYear(2019);
LocalDate date3 = date2.withDayOfMonth(25);
LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9);
</code></pre><p>它们都声明于Temporal接口，所有的日期和时间API类都实现这两个方法，它们定义了单点的时间，比如LocalDate、LocalTime、LocalDateTime以及Instant。更确切地说，使用get和with方法，我们可以将Temporal对象值的读取和修改区分开。如果Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常，比如试图访问Instant对象的ChronoField.MONTH_OF_YEAR字段，或者LocalDate对象的ChronoField.NANO_OF_SECOND字段时都会抛出这样的异常。</p>
<pre><code>// 以声明的方式操纵LocalDate对象,可以加上或者减去一段时间
LocalDate date1 = LocalDate.of(2014, 10, 19);
LocalDate date2 = date1.plusWeeks(1);
LocalDate date3 = date2.minusYears(3);
LocalDate date4 = date3.plus(6, ChronoUnit.MONTHS);
</code></pre><p>与我们刚才介绍的get和with方法类似最后一行使用的plus方法也是通用方法，它和minus方法都声明于Temporal接口中。通过这些方法，对TemporalUnit对象加上或者减去一个数字，我们能非常方便地将Temporal对象前溯或者回滚至某个时间段，通过ChronoUnit枚举我们可以非常方便地实现TemporalUnit接口。</p>
<p>###6. 使用TemporalAdjuster</p>
<p>有时需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。</p>
<pre><code>// 对于最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问。
LocalDate date1 = LocalDate.of(2013, 12, 11);
LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));
LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());
</code></pre><p>使用TemporalAdjuster可以进行更加复杂的日期操作，方法的名称很直观。如果没有找到符合预期的预定义的TemporalAdjuster，可以创建自定义的TemporalAdjuster。TemporalAdjuster接口只声明一个方法（即函数式接口）。实现该接口需要定义如何将一个Temporal对象转换为另一个Temporal对象,可以把它看成一个UnaryOperator。</p>
<pre><code>@FunctionalInterface
public interface TemporalAdjuster {
    Temporal adjustInto(Temporal temporal);
}
</code></pre><p>###7. 打印输出及解析日期-时间对象</p>
<p>新的java.time.format包就是特别为格式化以及解析日期-时间对象而设计的。其中最重要的类是DateTimeFormatter。创建格式器最简单的方法是通过它的静态工厂方法以及常量。所有的DateTimeFormatter实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<pre><code>LocalDate date = LocalDate.of(2013, 10, 11);
String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);
String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);

20131011
2013-10-11
</code></pre><p>通过解析代表日期或时间的字符串重新创建该日期对象，也可以使用工厂方法parse重新创建。</p>
<pre><code>LocalDate date2 = LocalDate.parse(&quot;20141007&quot;, DateTimeFormatter.BASIC_ISO_DATE);
LocalDate date3 = LocalDate.parse(&quot;2014-10-07&quot;, DateTimeFormatter.ISO_LOCAL_DATE);
</code></pre><p>DateTimeFormatter实例是线程安全的，老的java.util.DateFormat线程不安全。单例模式创建格式器实例，在多个线程间共享实例是没有问题的。也可以通过ofPattern静态工厂方法，按照某个特定的模式创建格式器。</p>
<pre><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);
String formattedDateStr = date.format(formatter);
LocalDate date1 = LocalDate.parse(formattedDateStr, formatter);
</code></pre><p>ofPattern方法也提供了一个重载的版本，可以传入Locale创建格式器。</p>
<pre><code>DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(&quot;d. MMMM yyyy&quot;, Locale.ITALIAN);
LocalDate date = LocalDate.of(2015, 11, 14);
String formattedDate = date.format(italianFormatter);
LocalDate date1 = LocalDate.parse(formattedDate, italianFormatter);
</code></pre><p>DateTimeFormatterBuilder类还提供了更复杂的格式器,以提供更加细粒度的控制。同时也提供非常强大的解析功能，比如区分大小写的解析、柔性解析、填充，以及在格式器中指定可选节等等。</p>
<p>通过DateTimeFormatterBuilder自定义格式器</p>
<pre><code>DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder()
                .appendText(ChronoField.DAY_OF_MONTH)
                .appendLiteral(&quot;. &quot;)
                .appendText(ChronoField.MONTH_OF_YEAR)
                .appendLiteral(&quot; &quot;)
                .appendText(ChronoField.YEAR)
                .parseCaseInsensitive()
                .toFormatter(Locale.ITALIAN);
LocalDate now = LocalDate.now();
String s = now.format(italianFormatter);
</code></pre><p>###8. 处理不同的时区和历法</p>
<p>新版日期和时间API新增加的重要功能是时区的处理。新的java.time.ZoneId类替代老版java.util.TimeZone。跟其他日期和时间类一样，ZoneId类也是无法修改的。是按照一定的规则将区域划分成的标准时间相同的区间。在ZoneRules这个类中包含了40个时区实例,可以通过调用ZoneId的getRules()得到指定时区的规则,每个特定的ZoneId对象都由一个地区ID标识。</p>
<pre><code>ZoneId shanghaiZone = ZoneId.of(&quot;Asia/Shanghai&quot;);
</code></pre><p>Java 8的新方法toZoneId将一个老的时区对象转换为ZoneId。地区ID都为“{区域}/{城市}”的格式，地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p>
<pre><code>ZoneId zoneId = TimeZone.getDefault().toZoneId();
</code></pre><p>ZoneId对象可以与LocalDate、LocalDateTime或者是Instant对象整合构造为成ZonedDateTime实例，它代表了相对于指定时区的时间点。</p>
<pre><code>LocalDate date = LocalDate.of(2019, 03, 27);
ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);

LocalDateTime dateTime = LocalDateTime.of(2015, 12, 21, 11, 11, 11);
ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);

Instant instant = Instant.now();
ZonedDateTime zdt3 = instant.atZone(shanghaiZone);
通过ZoneId，你还可以将LocalDateTime转换为Instant：

LocalDateTime dateTime = LocalDateTime.of(2016, 10, 14, 15, 35);
Instant instantFromDateTime = dateTime.toInstant(shanghaiZone);
你也可以通过反向的方式得到LocalDateTime对象：

Instant instant = Instant.now();
LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, shanghaiZone);
</code></pre><p>另一种比较通用的表达时区的方式是利用当前时区和UTC/格林尼治的固定偏差。使用ZoneId的一个子类ZoneOffset，表示的是当前时间和伦敦格林尼治子午线时间的差异：</p>
<pre><code>ZoneOffset newYorkOffset = ZoneOffset.of(&quot;-05:00&quot;);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/" data-id="cjy9xsodj000br4v8m6qdfpk4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/my-blog/page/2/">2</a><a class="extend next" rel="next" href="/my-blog/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blog/2019/07/19/Feign配置问题/">Feign配置问题</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/07/05/Cleanup/">cleanup 自动资源管理</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/06/28/Spring Boot实现confirm机制及ack消费端主动回调/">RabbitMQ数据丢失问题，Spring Boot实现confirm机制及ack消费端主动回调</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/06/21/适配器模式/">适配器模式</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/06/14/commons-lang3-3.2.jar中的常用工具类的使用/">commons-lang3-3.2.jar中的常用工具类的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/my-blog/fancybox/jquery.fancybox.css">
  <script src="/my-blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/my-blog/js/script.js"></script>



  </div>
</body>
</html>