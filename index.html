<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/zhaoqixing/my-blog.git/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/my-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/my-blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blog/">Home</a>
        
          <a class="main-nav-link" href="/my-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/zhaoqixing/my-blog.git"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Jackson相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/06/Jackson相关/" class="article-date">
  <time datetime="2019-06-06T13:17:12.724Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/06/Jackson相关/">jackson 相关认识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="spring是如何将string-通过jackson变成java对象的"><a href="#spring是如何将string-通过jackson变成java对象的" class="headerlink" title="spring是如何将string 通过jackson变成java对象的"></a>spring是如何将string 通过jackson变成java对象的</h3><p>Spring Boot支持与三种JSON mapping库集成：Gson、Jackson和JSON-B。Jackson是首选和默认的。</p>
<p>Jackson是spring-boot-starter-json的一部分，spring-boot-starter-web中包含spring-boot-starter-json。也就是说，当项目中引入spring-boot-starter-web后会自动引入spring-boot-starter-json。</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre><p>ObjectMapper是jackson-databind包中的一个类，提供读写JSON的功能，可以方便的进行对象和JSON转换：</p>
<pre><code>import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public final class JsonUtil {
    private static ObjectMapper mapper = new ObjectMapper();

    private JsonUtil() {
    }

    /**
     * Serialize any Java value as a String.
     */
    public static String generate(Object object) throws JsonProcessingException {
        return mapper.writeValueAsString(object);
    }

    /**
     * Deserialize JSON content from given JSON content String.
     */
    public static &lt;T&gt; T parse(String content, Class&lt;T&gt; valueType) throws IOException {
        return mapper.readValue(content, valueType);
    }
}    
</code></pre><p>编写一简单POJO测试类：</p>
<pre><code>import java.util.Date;

public class Hero {

    public static void main(String[] args) throws Exception {
        System.out.println(JsonUtil.generate(new Hero(&quot;Jason&quot;, new Date())));
    }

    private String name;

    private Date birthday;

    public Hero() {
    }

    public Hero(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public Date getBirthday() {
        return birthday;
    }
} 
</code></pre><p>运行后输出结果如下：</p>
<pre><code>{&quot;name&quot;:&quot;Jason&quot;,&quot;birthday&quot;:1540909420353}    
</code></pre><h4 id="关于使用Feign的feign-master包中通过feign-jackson-JacksonEncoder、feign-jackson-JacksonDecoder类基于jackson进行加密解密"><a href="#关于使用Feign的feign-master包中通过feign-jackson-JacksonEncoder、feign-jackson-JacksonDecoder类基于jackson进行加密解密" class="headerlink" title="关于使用Feign的feign-master包中通过feign.jackson.JacksonEncoder、feign.jackson.JacksonDecoder类基于jackson进行加密解密"></a>关于使用Feign的feign-master包中通过feign.jackson.JacksonEncoder、feign.jackson.JacksonDecoder类基于jackson进行加密解密</h4><p>源码说明</p>
<pre><code>1.JacksonEncoder加密类

    package feign.jackson;

    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.JavaType;
    import com.fasterxml.jackson.databind.Module;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import com.fasterxml.jackson.databind.SerializationFeature;

    import java.lang.reflect.Type;
    import java.util.Collections;

    import feign.RequestTemplate;
    import feign.codec.EncodeException;
    import feign.codec.Encoder;

    public class JacksonEncoder implements Encoder {

      private final ObjectMapper mapper;

      public JacksonEncoder() {
        this(Collections.&lt;Module&gt;emptyList());
      }

      public JacksonEncoder(Iterable&lt;Module&gt; modules) {
        this(new ObjectMapper()
                 .setSerializationInclusion(JsonInclude.Include.NON_NULL)
                 .configure(SerializationFeature.INDENT_OUTPUT, true)
                 .registerModules(modules));
      }

      public JacksonEncoder(ObjectMapper mapper) {
        this.mapper = mapper;
      }

      @Override
      public void encode(Object object, Type bodyType, RequestTemplate template) {
        try {
          JavaType javaType = mapper.getTypeFactory().constructType(bodyType);
          template.body(mapper.writerFor(javaType).writeValueAsString(object));
        } catch (JsonProcessingException e) {
          throw new EncodeException(e.getMessage(), e);
        }
      }
    }
</code></pre><p>2.JacksonDecoder解密类</p>
<pre><code>package feign.jackson;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.RuntimeJsonMappingException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.Collections;

import feign.Response;
import feign.Util;
import feign.codec.Decoder;

public class JacksonDecoder implements Decoder {

  private final ObjectMapper mapper;

  public JacksonDecoder() {
    this(Collections.&lt;Module&gt;emptyList());
  }

  public JacksonDecoder(Iterable&lt;Module&gt; modules) {
    this(new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
             .registerModules(modules));
  }

  public JacksonDecoder(ObjectMapper mapper) {
    this.mapper = mapper;
  }

  @Override
  public Object decode(Response response, Type type) throws IOException {
    if (response.status() == 404) return Util.emptyValueOf(type);
    if (response.body() == null) return null;
    Reader reader = response.body().asReader();
    if (!reader.markSupported()) {
      reader = new BufferedReader(reader, 1);
    }
    try {
      // Read the first byte to see if we have any data
      reader.mark(1);
      if (reader.read() == -1) {
        return null; // Eagerly returning null avoids &quot;No content to map due to end-of-input&quot;
      }
      reader.reset();
      return mapper.readValue(reader, mapper.constructType(type));
    } catch (RuntimeJsonMappingException e) {
      if (e.getCause() != null &amp;&amp; e.getCause() instanceof IOException) {
        throw IOException.class.cast(e.getCause());
      }
      throw e;
    }
  }
} 
</code></pre><h4 id="ObjectMapper-是线程安全的吗？"><a href="#ObjectMapper-是线程安全的吗？" class="headerlink" title="ObjectMapper 是线程安全的吗？"></a>ObjectMapper 是线程安全的吗？</h4><p>是的，官方注释中这样回应的：</p>
<pre><code>Is ObjectMapper thread-safe? Short answer: yes Long answer: yes, as long as you always configure instance before use, and do not call configure 
methods during operation (or synchronize such calls appropriately). Usually it is better to construct separate mapper instance if configurations differ in any case.   
</code></pre><h4 id="为什么spring可以正确解析-application-jason-application-form-等"><a href="#为什么spring可以正确解析-application-jason-application-form-等" class="headerlink" title="为什么spring可以正确解析 application/jason  application/form 等"></a>为什么spring可以正确解析 application/jason  application/form 等</h4><p>@RequestBody</p>
<p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；</p>
<p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</p>
<p>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里</p>
<p>@RestController中有@ResponseBody，可以帮我们把对象列化到resp.body中。@RequestBody可以帮我们把req.body的内容转化为对象。如果是开发Web应用，一般<br>这两个注解对应的就是Json序列化和反序列化的操作。这里实际上已经体现了Http序列化/反序列化这个过程，只不过和普通的对象序列化有些不一样，Http序列化/反序<br>列化的层次更高，属于一种Object2Object之间的转换。<br>Http序列化和反序列化的核心是HttpMessageConverter。用过老版本springmvc的可能有些印象，那时候需要在xml配置文件中注入MappingJackson2HttpMessageConverter<br>这个类型的bean，告诉springmvc我们需要进行Json格式的转换，它就是HttpMessageConverter的一种实现。</p>
<h4 id="spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成-fastjson"><a href="#spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成-fastjson" class="headerlink" title="spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成 fastjson"></a>spring支持哪些json解析，如果做，才能将spring默认的json解析工具变成 fastjson</h4><p>Spring Boot支持与三种JSON mapping库集成：Gson、Jackson和JSON-B。Jackson是首选和默认的。<br>如果使用fastjson，可以按照下列方式配置使用</p>
<p>引入fastjson依赖库</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.46&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

compile(&quot;com.alibaba:fastjson:${fastJsonVersion}&quot;)
ext {
        fastJsonVersion    = &apos;1.2.46&apos;
    }
</code></pre><p>注： 这里要说下很重要的话，官方文档说的1.2.10以后，会有两个方法支持HttpMessageconvert，一个是FastJsonHttpMessageConverter，支持4.2以下的版本，<br>        一个是FastJsonHttpMessageConverter4支持4.2以上的版本，具体有什么区别暂时没有深入研究。这里也就是说：低版本的就不支持了，所以这里最低要求就是1.2.10+</p>
<p>在启动类中配置</p>
<p>配置方式一（通过继承的方式）</p>
<p>　　1、启动类继承WebMvcConfigurerAdapter<br>　　2、重写configureMessageConverters方法</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableScheduling
public class MemberApplication extends WebMvcConfigurerAdapter {
    /**
     * 配置FastJson为方式一
     * @return*/
    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        super.configureMessageConverters(converters);
        /*
         * 1、需要先定义一个convert转换消息的对象 2、添加fastJson的配置信息，比如：是否要格式化返回json数据 3、在convert中添加配置信息
         * 4、将convert添加到converters当中
         * 
         */
        // 1、需要先定义一个·convert转换消息的对象；
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2、添加fastjson的配置信息，比如 是否要格式化返回json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3、在convert中添加配置信息.
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4、将convert添加到converters当中.
        converters.add(fastConverter);
    }

    public static void main(String[] args) {
        SpringApplication.run(MemberApplication.class, args);
    }

}
</code></pre><p>注：开发中为了统一管理配置，可以放入配置类中，启动类只做启动的功能</p>
<pre><code>@Configuration
public class HttpConverterConfig {

    @Bean
    public HttpMessageConverters fastJsonHttpMessageConverters() {
        // 1.定义一个converters转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3.在converter中添加配置信息
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4.将converter赋值给HttpMessageConverter
        HttpMessageConverter&lt;?&gt; converter = fastConverter;
        // 5.返回HttpMessageConverters对象
        return new HttpMessageConverters(converter);
    }
}
</code></pre><p>配置方式二（通过@Bean注入的方式）<br>在App.java启动类中，注入Bean : HttpMessageConverters</p>
<pre><code>@SpringBootApplication
@EnableDiscoveryClient
@EnableScheduling
public class MemberApplication {
    /**
     * 配置FastJson方式二
     * @return  HttpMessageConverters
     */
    @Bean
    public HttpMessageConverters fastJsonHttpMessageConverters() {
        // 1.定义一个converters转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        // 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        // 3.在converter中添加配置信息
        fastConverter.setFastJsonConfig(fastJsonConfig);
        // 4.将converter赋值给HttpMessageConverter
        HttpMessageConverter&lt;?&gt; converter = fastConverter;
        // 5.返回HttpMessageConverters对象
        return new HttpMessageConverters(converter);
    }

    public static void main(String[] args) {
        SpringApplication.run(MemberApplication.class, args);
    }

}
</code></pre><p>在pojo类中：</p>
<pre><code>private int id;
private String name;

//com.alibaba.fastjson.annotation.JSONField
@JSONField(format=&quot;yyyy-MM-dd HH:mm&quot;)
private Date createTime;//创建时间.

/*
 * serialize:是否需要序列化属性.
 */
@JSONField(serialize=false)
private String remarks;//备注信息.
</code></pre><p>那么这时候在实体类中使用@JSONField(serialize=false)，是不是此字段就不返回了，如果是的话，那么就配置成功了，其中JSONField的包路径是：com.alibaba.fastjson.annotation.JSONField。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/06/06/Jackson相关/" data-id="cjwkosdyb0004tgv8qbpqzy6b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/31/代理模式/" class="article-date">
  <time datetime="2019-05-31T11:58:01.357Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/31/代理模式/">代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###如何理解代理模式？<br>思考抽象问题最好的办法就是具体化！</p>
<p>比如我们需要为一个业务方法在执行前后记录日志，为了达到解耦的目的，我们可以再新建一个类并定义一个新的业务方法，该方法既可以调用原业务方法，又可以在调用前后进行日志处理，例如：</p>
<pre><code>CarProxy.class

public void move() {
    System.out.println(&quot;日志开始记录....&quot;);
    new Car().move();
    System.out.println(&quot;日志记录完成....&quot;);
}
</code></pre><p>代理模式的应用很多，比如Spring容器的延迟加载，AOP增强处理等。</p>
<p>####一：静态代理</p>
<pre><code>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。

所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
</code></pre><p>一句话，自己手写代理类就是静态代理。</p>
<p>####基于继承的静态代理</p>
<p>目标对象：定义一个普通方法<br>    public class Car {</p>
<pre><code>    public void move() {
        System.out.println(&quot;1.汽车开始跑步&quot;);
        System.out.println(&quot;2.汽车跑到了终点&quot;);
    }

}
</code></pre><p>代理对象：主要作用是继承目标对象，进行增强处理，并使用关键字super调用父类方法。</p>
<pre><code>public class CarProxy extends Car {

    @Override
    public void move() {
        System.out.println(&quot;日志开始记录....&quot;);
        super.move();
        System.out.println(&quot;日志记录完成....&quot;);
    }

}
</code></pre><p>测试方法：实际上是调用代理对象的move()方法。</p>
<pre><code>public static void main(String[] args) {
        Car car = new CarProxy();
        car.move();
    }
</code></pre><p>####基于接口的静态代理</p>
<p>共同接口：定义一个普通的接口方法</p>
<pre><code>public interface Moveable {
    void move();
}
</code></pre><p>目标对象：实现该接口方法。</p>
<pre><code>public class Car implements Moveable {

    @Override
    public void move() {
        System.out.println(&quot;汽车行驶中....&quot;);
    }

}
</code></pre><p>代理对象：调用目标对象的方法，并在调用前后进行增强处理。</p>
<pre><code>public class CarProxy implements Moveable{
    private Moveable move;

    @Override
    public void move() {
        if(move==null){
            move = new Car();
        }
        System.out.println(&quot;开始记录日志：&quot;);
        move.move();
        System.out.println(&quot;记录日志结束！&quot;);

    }
}
</code></pre><p>测试方法：实际上是调用代理对象的move()方法。</p>
<pre><code>public static void main(String[] args) throws Exception {
    Moveable m =new CarProxy();
    m.move();
}
</code></pre><p>###静态代理的优缺点</p>
<p>#####优点：</p>
<p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理模式的共有优点。</p>
<p>#####缺点：</p>
<p>1）代理对象的一个接口只服务于一种类型的对象，如果要代理的类型很多，势必要为每一种类型的方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</p>
<p>   比如Car类的move()方法需要记录日志，如果还有汽车，火车，自行车类的move()方法也需要记录日志，我们都要一个个的去为它们生成代理类，太麻烦了。</p>
<p>2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。显而易见，增加了代码维护的复杂度。 </p>
<p>###二：动态代理</p>
<pre><code>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。

动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成 。
</code></pre><p>简单来说，动态代理就是交给程序去自动生成代理类。</p>
<p>###JDK的动态代理</p>
<p>JDK动态代理实现步骤：</p>
<pre><code>创建被代理的类以及实现的接口；
创建一个实现接口InvocationHandler的类，它必须实现invoke方法；
调用Proxy的newProxyInstance静态方法，创建一个代理类。
通过代理对象调用目标方法。
</code></pre><p>####代码示例</p>
<p>共同接口        </p>
<pre><code>public interface Moveable {
    String move();
}
</code></pre><p>目标对象：正常实现接口方法</p>
<pre><code>public class Car implements Moveable {

    @Override
    public String move() {
        return &quot;汽车行驶中&quot;;
    }

}    
</code></pre><p>对目标对象的增强处理：</p>
<pre><code>public class LogHandler implements InvocationHandler{
    private Object target;

    public LogHandler(Object object){
        super();
        this.target =  object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //增强处理
        Object o = method.invoke(target,args);
        //增强处理
        return o;
    }

}
</code></pre><p>实现InvocationHandler接口步骤：</p>
<pre><code>定义含参构造方法，该参数为要代理的实例对象，目的是用于执行method.invoke()方法（也就是执行目标方法）

实现接口的invoke()方法，该方法用于对目标方法的增强处理，比如记录日志等。该方法的返回值就是代理对象执行目标方法的返回值。具体参数：

proxy 动态生成的代理对象

method 目标方法的实例

args 目标方法的参数
</code></pre><p>测试方法：</p>
<pre><code>public static void main(String[] args) {
    Moveable move =  (Moveable) Proxy.newProxyInstance(Car.class.getClassLoader(), Car.class.getInterfaces(), new LogHandler(new Car()));

    System.out.println(&quot;代理对象:&quot;+move.getClass().getName());
    System.out.println(&quot;执行方法:&quot;+move.move());
}
</code></pre><p>通过调用Proxy.newProxyInstance方法生成代理对象，具体参数有：</p>
<pre><code>loader 目标类的类加载器
interfaces 目标类实现的接口
InvocationHandler 调用处理程序的实现对象
</code></pre><p>打印结果</p>
<pre><code>代理对象:com.sun.proxy.$Proxy0
执行方法:汽车行驶中
</code></pre><p>值得一提的是，JDK动态代理针对每个代理对象都会有一个关联的调用处理程序，即实现InvocationHandler接口。当在代理对象上调用目标方法时，将对方法调用进行编码并将其分配给其实现 InvocationHandler 接口的 invoke 方法。</p>
<p>####特点</p>
<p>JDK的动态代理只能代理实现了接口的类， 没有实现接口的类不能实现动态代理</p>
<p>###cglib的动态代理</p>
<p>引用cglib的依赖包</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>执行步骤按顺序写下</p>
<pre><code>public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        //设置父类，被代理类（这里是Car.class）
        enhancer.setSuperclass(Car.class);
        //设置回调函数
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                //增强处理...
                Object o= proxy.invokeSuper(obj, args);//代理类调用父类的方法
                //增强处理...
                return o;
            }
        });
        //创建代理类并使用回调（用父类Car去引用）
        Car car = (Car) enhancer.create();
        //执行目标方法
        System.out.println(car.move());
    }
</code></pre><p>####方法拦截器</p>
<p>实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法。</p>
<p>intercept方法的具体参数有</p>
<pre><code>obj 目标类的实例
method 目标方法实例（通过反射获取的目标方法实例）
args 目标方法的参数
proxy 代理类的实例
</code></pre><p>该方法的返回值就是目标方法的返回值。</p>
<p>####特点</p>
<pre><code>cglib的动态代理是针对类来实现代理。
对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。
因为是通过继承实现，final类无法使用。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/31/代理模式/" data-id="cjwkosdyl0007tgv83e81wx1l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Jackson快速入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/24/Jackson快速入门/" class="article-date">
  <time datetime="2019-05-24T11:05:30.819Z" itemprop="datePublished">2019-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/24/Jackson快速入门/">jackson 快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。</p>
<p>###引入类库</p>
<pre><code>ext {
    jacksonVersion = &apos;2.9.5&apos;
}

dependencies {
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-core&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-databind&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-annotations&apos;, version: jacksonVersion
    // 引入XML功能
    compile group: &apos;com.fasterxml.jackson.dataformat&apos;, name: &apos;jackson-dataformat-xml&apos;, version: jacksonVersion
    // 比JDK自带XML实现更高效的类库
    compile group: &apos;com.fasterxml.woodstox&apos;, name: &apos;woodstox-core&apos;, version: &apos;5.1.0&apos;
    // Java 8 新功能
    compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jsr310&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.module&apos;, name: &apos;jackson-module-parameter-names&apos;, version: jacksonVersion
    compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jdk8&apos;, version: jacksonVersion

    compileOnly group: &apos;org.projectlombok&apos;, name: &apos;lombok&apos;, version: &apos;1.16.22&apos;
}
</code></pre><p>###属性命名<br>@JsonProperty注解指定一个属性用于JSON映射，默认情况下映射的JSON属性与注解的属性名称相同，不过可以使用该注解的value值修改JSON属性名，该注解还有一个index属性指定生成JSON属性的顺序，如果有必要的话。</p>
<p>###属性包含<br>还有一些注解可以管理在映射JSON的时候包含或排除某些属性，下面介绍一下常用的几个。</p>
<p>@JsonIgnore注解用于排除某个属性，这样该属性就不会被Jackson序列化和反序列化。</p>
<p>@JsonIgnoreProperties注解是类注解。在序列化为JSON的时候，@JsonIgnoreProperties({“prop1”, “prop2”})会忽略pro1和pro2两个属性。在从JSON反序列化为Java类的时候，@JsonIgnoreProperties(ignoreUnknown=true)会忽略所有没有Getter和Setter的属性。该注解在Java类和JSON不完全匹配的时候很有用。</p>
<p>@JsonIgnoreType也是类注解，会排除所有指定类型的属性。</p>
<p>###序列化相关<br>@JsonPropertyOrder和@JsonProperty的index属性类似，指定属性序列化时的顺序。</p>
<p>@JsonRootName注解用于指定JSON根属性的名称。</p>
<p>###处理JSON</p>
<p>###简单映射<br>我们用Lombok设置一个简单的Java类。</p>
<pre><code>@Data
@AllArgsConstructor
@NoArgsConstructor
public class Friend {
    private String nickname;
    private int age;
}
</code></pre><p>然后就可以处理JSON数据了。首先需要一个ObjectMapper对象，序列化和反序列化都需要它。</p>
<pre><code>ObjectMapper mapper = new ObjectMapper();
Friend friend = new Friend(&quot;yitian&quot;, 25);

// 写为字符串
String text = mapper.writeValueAsString(friend);
// 写为文件
mapper.writeValue(new File(&quot;friend.json&quot;), friend);
// 写为字节流
byte[] bytes = mapper.writeValueAsBytes(friend);
System.out.println(text);
// 从字符串中读取
Friend newFriend = mapper.readValue(text, Friend.class);
// 从字节流中读取
newFriend = mapper.readValue(bytes, Friend.class);
// 从文件中读取
newFriend = mapper.readValue(new File(&quot;friend.json&quot;), Friend.class);
System.out.println(newFriend);
</code></pre><p>程序结果如下。可以看到生成的JSON属性和Java类中定义的一致。</p>
<pre><code>{&quot;nickname&quot;:&quot;yitian&quot;,&quot;age&quot;:25}
Friend(nickname=yitian, age=25)
</code></pre><p>###集合的映射</p>
<p>除了使用Java类进行映射之外，我们还可以直接使用Map和List等Java集合组织JSON数据，在需要的时候可以使用readTree方法直接读取JSON中的某个属性值。需要注意的是从JSON转换为Map对象的时候，由于Java的类型擦除，所以类型需要我们手动用new TypeReference<t>给出。</t></p>
<pre><code>ObjectMapper mapper = new ObjectMapper();

Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;age&quot;, 25);
map.put(&quot;name&quot;, &quot;yitian&quot;);
map.put(&quot;interests&quot;, new String[]{&quot;pc games&quot;, &quot;music&quot;});

String text = mapper.writeValueAsString(map);
System.out.println(text);

Map&lt;String, Object&gt; map2 = mapper.readValue(text, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {
});
System.out.println(map2);

JsonNode root = mapper.readTree(text);
String name = root.get(&quot;name&quot;).asText();
int age = root.get(&quot;age&quot;).asInt();

System.out.println(&quot;name:&quot; + name + &quot; age:&quot; + age);
</code></pre><p>程序结果如下。</p>
<pre><code>{&quot;name&quot;:&quot;yitian&quot;,&quot;interests&quot;:[&quot;pc games&quot;,&quot;music&quot;],&quot;age&quot;:25}
{name=yitian, interests=[pc games, music], age=25}
name:yitian age:25
</code></pre><p>###Jackson配置</p>
<p>Jackson预定义了一些配置，我们通过启用和禁用某些属性可以修改Jackson运行的某些行为。详细文档参考JacksonFeatures。下面我简单翻译一下Jackson README上列出的一些属性。</p>
<pre><code>// 美化输出
mapper.enable(SerializationFeature.INDENT_OUTPUT);
// 允许序列化空的POJO类
// （否则会抛出异常）
mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
// 把java.util.Date, Calendar输出为数字（时间戳）
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

// 在遇到未知属性的时候不抛出异常
mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
// 强制JSON 空字符串(&quot;&quot;)转换为null对象值:
mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);

// 在JSON中允许C/C++ 样式的注释(非标准，默认禁用)
mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
// 允许没有引号的字段名（非标准）
mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
// 允许单引号（非标准）
mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
// 强制转义非ASCII字符
mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);
// 将内容包裹为一个JSON属性，属性名由@JsonRootName注解指定
mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);
</code></pre><p>这里有三个方法，configure方法接受配置名和要设置的值，Jackson 2.5版本新加的enable和disable方法则直接启用和禁用相应属性，推荐使用后面两个方法。</p>
<p>###用注解管理映射</p>
<p>前面介绍了一些Jackson注解，下面来应用一下这些注解。首先来看看使用了注解的Java类。</p>
<pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonRootName(&quot;FriendDetail&quot;)
@JsonIgnoreProperties({&quot;uselessProp1&quot;, &quot;uselessProp3&quot;})
public class FriendDetail {
    @JsonProperty(&quot;NickName&quot;)
    private String name;
    @JsonProperty(&quot;Age&quot;)
    private int age;
    private String uselessProp1;
    @JsonIgnore
    private int uselessProp2;
    private String uselessProp3;
}
</code></pre><p>然后看看代码。需要注意的是，由于设置了排除的属性，所以生成的JSON和Java类并不是完全对应关系，所以禁用DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES是必要的。</p>
<pre><code>ObjectMapper mapper = new ObjectMapper();
//mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
FriendDetail fd = new FriendDetail(&quot;yitian&quot;, 25, &quot;&quot;, 0, &quot;&quot;);
String text = mapper.writeValueAsString(fd);
System.out.println(text);

FriendDetail fd2 = mapper.readValue(text, FriendDetail.class);
System.out.println(fd2);
</code></pre><p>运行结果如下。可以看到生成JSON的时候忽略了我们制定的值，而且在转换为Java类的时候对应的属性为空。</p>
<pre><code>{&quot;NickName&quot;:&quot;yitian&quot;,&quot;Age&quot;:25}
FriendDetail(name=yitian, age=25, uselessProp1=null, uselessProp2=0, uselessProp3=null)
</code></pre><p>##处理XML</p>
<p>Jackson是一个处理JSON的类库，不过它也通过jackson-dataformat-xml包提供了处理XML的功能。Jackson建议我们在处理XML的时候使用woodstox-core包，它是一个XML的实现，比JDK自带XML实现更加高效，也更加安全。</p>
<p>这里有个注意事项，如果你正在使用Java 9以上的JDK，可能会出现java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException异常，这是因为Java 9实现了JDK的模块化，将原本和JDK打包在一起的JAXB实现分隔出来。所以这时候需要我们手动添加JAXB的实现。在Gradle中添加下面的代码即可。</p>
<pre><code>compile group: &apos;javax.xml.bind&apos;, name: &apos;jaxb-api&apos;, version: &apos;2.3.0&apos;
</code></pre><p>###注解</p>
<p>Jackson XML除了使用Jackson JSON和JDK JAXB的一些注解之外，自己也定义了一些注解。下面简单介绍一下几个常用注解。</p>
<p>@JacksonXmlProperty注解有三个属性，namespace和localname属性用于指定XML命名空间的名称，isAttribute指定该属性作为XML的属性（）还是作为子标签（）.</p>
<p>@JacksonXmlRootElement注解有两个属性，namespace和localname属性用于指定XML根元素命名空间的名称。</p>
<p>@JacksonXmlText注解将属性直接作为未被标签包裹的普通文本表现。</p>
<p>@JacksonXmlCData将属性包裹在CDATA标签中。</p>
<p>###XML映射</p>
<p>新建如下一个Java类。</p>
<pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonRootName(&quot;Person&quot;)
public class Person {
    @JsonProperty(&quot;Name&quot;)
    private String name;
    @JsonProperty(&quot;NickName&quot;)
    //@JacksonXmlText
    private String nickname;
    @JsonProperty(&quot;Age&quot;)
    private int age;
    @JsonProperty(&quot;IdentityCode&quot;)
    @JacksonXmlCData
    private String identityCode;
    @JsonProperty(&quot;Birthday&quot;)
    //@JacksonXmlProperty(isAttribute = true)
    @JsonFormat(pattern = &quot;yyyy/MM/DD&quot;)
    private LocalDate birthday;

}
</code></pre><p>下面是代码示例，基本上和JSON的API非常相似，XmlMapper实际上就是ObjectMapper的子类。</p>
<pre><code>Person p1 = new Person(&quot;yitian&quot;, &quot;易天&quot;, 25, &quot;10000&quot;, LocalDate.of(1994, 1, 1));
XmlMapper mapper = new XmlMapper();
mapper.findAndRegisterModules();
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
mapper.enable(SerializationFeature.INDENT_OUTPUT);
String text = mapper.writeValueAsString(p1);
System.out.println(text);

Person p2 = mapper.readValue(text, Person.class);
System.out.println(p2);
</code></pre><p>运行结果如下。</p>
<pre><code>&lt;Person&gt;
  &lt;Name&gt;yitian&lt;/Name&gt;
  &lt;NickName&gt;易天&lt;/NickName&gt;
  &lt;Age&gt;25&lt;/Age&gt;
  &lt;IdentityCode&gt;&lt;![CDATA[10000]]&gt;&lt;/IdentityCode&gt;
  &lt;Birthday&gt;1994/01/01&lt;/Birthday&gt;
&lt;/Person&gt;

Person(name=yitian, nickname=易天, age=25, identityCode=10000, birthday=1994-01-01)
</code></pre><p>如果取消那两行注释，那么运行结果如下。可以看到Jackson XML注解对生成的XML的控制效果。</p>
<pre><code>&lt;Person birthday=&quot;1994/01/01&quot;&gt;
  &lt;Name&gt;yitian&lt;/Name&gt;易天
  &lt;Age&gt;25&lt;/Age&gt;
  &lt;IdentityCode&gt;&lt;![CDATA[10000]]&gt;&lt;/IdentityCode&gt;
&lt;/Person&gt;

Person(name=yitian, nickname=null, age=25, identityCode=10000, birthday=1994-01-01)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/24/Jackson快速入门/" data-id="cjwkosdyc0005tgv8jax0omet" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git回滚远程仓库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/10/git回滚远程仓库/" class="article-date">
  <time datetime="2019-05-10T13:58:55.465Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/10/git回滚远程仓库/">git回滚远程仓库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>使用git管理项目开发的过程中经常会碰到这种情况：某次提交已经push到了远程仓库，可是突然意识到“天哪，我怎么做了这么蠢的事情”。那么问题来了，怎么将远程代码库回滚呢？

在网上看到大部分人给出的解决方案是先将本地回滚，然后删除远程分支，之后再将本地的分支push到远程仓库，这其实是一种很危险的方案，毕竟直接删除远程分支太狠了，不推荐这样做。。。
</code></pre><p>###关于远程仓库回滚</p>
<p>####1、删除最后一次提交<br>这种情况是最简单的了，只需要以下两步就可以了</p>
<pre><code>git revert HEAD
git push origin master
</code></pre><p>注意，revert和reset的区别:</p>
<p>revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在，而reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。如果还没有理解的话，我们做如下测试：<br>假设我们有以下三次提交记录：</p>
<p>log</p>
<p>现在我们使用revert放弃最后一次提交，之后执行git log：</p>
<pre><code>git revert HEAD
git log
</code></pre><p>历史记录中还有第三次提交的记录，并且多了一次的提交，但是仓库内容已经回到了第二次提交之后的状态。 现在我们使用reset回到第三次提交，之后执行git log：</p>
<pre><code>git reset --hard HEAD^
git log
</code></pre><p>历史记录中已经没有之前revert生成的提交记录了，现在应该明白了吧。 如果删除远程仓库的最后一次提交的时候不需要保留历史记录的话，可以使用reset，命令如下：</p>
<pre><code>git reset --hard HEAD^
git push origin master -f
</code></pre><p>-f 参数是强制提交，因为reset之后本地库落后于远程库一个版本，因此需要强制提交。</p>
<p>####2、删除历史某次提交</p>
<p>这种情况需要先用git log命令在历史记录中查找到想要删除的某次提交的commit id，比如下图中圈出来的就是注释为”2”的提交的commit id（由此可见提交的注释很重要，一定要认真写）</p>
<p>然后执行以下命令（”commit id”替换为想要删除的提交的”commit id”，需要注意最后的^号，意思是commit id的前一次提交）：</p>
<pre><code>git rebase -i &quot;commit id&quot;^
</code></pre><p>执行该条命令之后会打开一个编辑框，内容如下，列出了包含该次提交在内之后的所有提交。</p>
<p>然后在编辑框中删除你想要删除的提交所在行，然后保存退出就好啦，如果有冲突的需要解决冲突。接下来，执行以下命令，将本地仓库提交到远程库就完成了：</p>
<pre><code>git push origin master -f     
</code></pre><p>3、修改历史某次提交</p>
<p>这种情况的解决方法类似于第二种情况，只需要在第二条打开编辑框之后，将你想要修改的提交所在行的pick替换成edit然后保存退出，这个时候rebase会停在你要修改的提交，然后做你需要的修改，修改完毕之后，执行以下命令：</p>
<pre><code>git add .
git commit --amend
git rebase --continue
</code></pre><p>如果你在之前的编辑框修改了n行，也就是说要对n次提交做修改，则需要重复执行以上步骤n次。</p>
<p>需要注意的是，在执行rebase命令对指定提交修改或删除之后，该次提交之后的所有提交的”commit id”都会改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/05/10/git回滚远程仓库/" data-id="cjwkosdxu0000tgv8tgbeefjk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《Java 8 in Action》Chapter 12：新的日期和时间API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/" class="article-date">
  <time datetime="2019-04-30T08:51:23.602Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/">《Java 8 in Action》Chapter 12：新的日期和时间API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。同时这个类还有两个很大的缺点：年份的起始选择是1900年，月份的起始从0开始。</p>
<p>在Java 1.1中，Date类中的很多方法被废弃，取而代之的是java.util.Calendar类。然而Calendar类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</p>
<p>###1. 使用LocalDate 和LocalTime</p>
<p>####1.1 LocalDate<br>  Java 8提供新的日期和时间API,LocalDate类实例是一个不可变对象，只提供简单的日期并且不含当天时间信息。此外也不附带任何与时区相关的信息。<br>  通过静态工厂方法of创建一个LocalDate实例。LocalDate实例提供了多种方法来读取敞亮的值，比如年份、月份、星期几等，如下所示。</p>
<pre><code>LocalDate localDate = LocalDate.of(2014, 3, 18);
int year = localDate.getYear();
Month month = localDate.getMonth();
int day = localDate.getDayOfMonth();
DayOfWeek dow = localDate.getDayOfWeek();
int len = localDate.lengthOfMonth();
boolean leap = localDate.isLeapYear();

// 使用工厂方法从系统时钟中获取当前的日期
LocalDate today = LocalDate.now();

System.out.println(String.format(&quot;year:%s\nmonth:%s\nday:%s\ndow:%s\nlen:%s\nleap:%s&quot;, year, month, day, dow, len, leap));
System.out.println(today);

 结果：
 year:2014  
 month:MARCH  
 day:18  
 dow:TUESDAY  
 len:  
 leap:false  
 2019-03-27  
</code></pre><p>  Java 8日期-时间类都提供了类似的工厂方法。通过传递TemporalField参数给get方法拿到同样的信息。TemporalField接口定义了如何访问temporal对象某个字段的值。ChronoField枚举实现TemporalField接口,可以使用get方法得到枚举元素的值。</p>
<pre><code>int year = localDate.get(ChronoField.YEAR);
int month = localDate.get(ChronoField.MONTH_OF_YEAR);
int day = localDate.get(ChronoField.DAY_OF_MONTH);
</code></pre><p>####1.2 LocalTime</p>
<p>   使用LocalTime类表示时间,可以使用of重载的两个工厂方法创建LocalTime的实例。</p>
<p>   &nbsp;&nbsp;&nbsp;&nbsp;第一个重载函数接收小时和分钟<br>   &nbsp;&nbsp;&nbsp;&nbsp;第二个重载函数同时还接收秒。</p>
<p>   LocalTime类也提供了一些get方法访问这些变量的值，如下所示。</p>
<pre><code>LocalTime localTime = LocalTime.of(13, 45, 20);
int hour = localTime.getHour();
int minute = localTime.getMinute();
int second = localTime.getSecond();
System.out.println(String.format(&quot;hour:%s\nminute:%s\nsecond:%s&quot;, hour, minute, second));

打印结果：
hour:13
minute:45
second:20
</code></pre><p>   LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse可以实现：</p>
<pre><code>LocalDate date = LocalDate.parse(&quot;2019-03-27&quot;);
LocalTime time = LocalTime.parse(&quot;20:17:08&quot;);

//可以向parse方法传递一个DateTimeFormatter。该类的实例定义了如何格式化一个日期或者时间对象。用来替换老版java.util.DateFormat。
//如果传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。
</code></pre><p>###2. 合并日期和时间</p>
<p>   复合类LocalDateTime，是LocalDate和LocalTime的合体。它同时表示了日期和时间，不带有时区信息。可以直接创建，也可以通过合并日期和时间对象构造。</p>
<pre><code>LocalTime time = LocalTime.of(21, 31, 50);
LocalDate date = LocalDate.of(2019, 03, 27);

LocalDateTime dt1 = LocalDateTime.of(2017, Month.NOVEMBER, 07, 22, 31, 51);
LocalDateTime dt2 = LocalDateTime.of(date, time);
LocalDateTime dt3 = date.atTime(22, 21, 14);
LocalDateTime dt4 = date.atTime(time);
LocalDateTime dt5 = time.atDate(date);
</code></pre><p>   创建LocalDateTime对象</p>
<p>   &nbsp;&nbsp;直接创建<br>   &nbsp;&nbsp;通过atTime方法向LocalDate传递一个时间对象<br>   &nbsp;&nbsp;通过atDate方法向LocalTime传递一个时间对象</p>
<p>   也可以使用toLocalDate或者toLocalTime方法，从LocalDateTime中提取LocalDate或者LocalTime组件：</p>
<pre><code>LocalDate date1 = dt1.toLocalDate();
LocalTime time1 = dt1.toLocalTime();
</code></pre><p>###3. 机器的日期和时间格式</p>
<p>   从计算机的角度来看，”2019年03月27日11:20:03”这样的方式是不容易理解的,计算机更加容易理解建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。新的java.time.Instant类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
<p>####3.1 创建Instant </p>
<p>   静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。<br>   静态工厂方法ofEpochSecond还有一个增强的重载版本，它接收第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整。重载的版本会调整纳秒参数，确保保存的纳秒分片在0到999 999999之间。</p>
<pre><code>Instant.ofEpochSecond(3);
Instant.ofEpochSecond(3, 0);
// 2 秒之后再加上100万纳秒（1秒）
Instant.ofEpochSecond(2, 1_000_000_000);
// 4秒之前的100万纳秒（1秒）
Instant.ofEpochSecond(4, -1_000_000_000);
</code></pre><p>####3.2 工厂方法now<br>Instant类也支持静态工厂方法now，它能够获取当前时刻的时间戳。<br>    Instant now = Instant.now();<br>    System.out.println(now);</p>
<pre><code>2019-03-27T03:26:39.451Z
</code></pre><p>Instant的设计初衷是为了便于机器使用,它包含的是由秒及纳秒所构成的数字。因此Instant无法处理那些我们非常容易理解的时间单位。</p>
<pre><code>int day = Instant.now().get(ChronoField.DAY_OF_MONTH);
它会抛出下面这样的异常：

Exception in thread &quot;main&quot; java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth
但是你可以通过Duration和Period类使用Instant，接下来我们会对这部分内容进行介绍。
</code></pre><p>###4. Duration和Period</p>
<p>####4.1 Duration</p>
<p>所有类都实现了Temporal接口，该接口定义如何读取和操纵为时间建模的对象的值。如果需要创建两个Temporal对象之间的duration,就需要Duration类的静态工厂方法between。<br>可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration：</p>
<pre><code>LocalTime time1 = LocalTime.of(21, 50, 10);
LocalTime time2 = LocalTime.of(22, 50, 10);
LocalDateTime dateTime1 = LocalDateTime.of(2019, 03, 27, 21, 20, 40);
LocalDateTime dateTime2 = LocalDateTime.of(2019, 03, 27, 21, 20, 40);
Instant instant1 = Instant.ofEpochSecond(1000 * 60 * 2);
Instant instant2 = Instant.ofEpochSecond(1000 * 60 * 3);

Duration d1 = Duration.between(time1, time2);
Duration d2 = Duration.between(dateTime1, dateTime2);
Duration d3 = Duration.between(instant1, instant2);
// PT1H 相差1小时
System.out.println(&quot;d1:&quot; + d1);
// PT2H 相差2小时
System.out.println(&quot;d2:&quot; + d2);
// PT16H40M 相差16小时40分钟
System.out.println(&quot;d3:&quot; + d3);
</code></pre><p>###4.2 Period</p>
<p>使用Period类以年、月或者日的方式对多个时间单位建模。使用该类的工厂方法between，可以使用得到两个LocalDate之间的时长。</p>
<pre><code>Period period = Period.between(LocalDate.of(2019, 03, 7), LocalDate.of(2019, 03, 17));
// 相差10天
System.out.println(&quot;Period between:&quot; + period);
</code></pre><p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例。</p>
<pre><code>Duration threeMinutes = Duration.ofMinutes(3);
Duration fourMinutes = Duration.of(4, ChronoUnit.MINUTES);

Period tenDay = Period.ofDays(10);
Period threeWeeks = Period.ofWeeks(3);
Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);
Duration类和Period类共享了很多相似的方法，有兴趣的可以参考官网的文档。
</code></pre><p>###5. 操纵、解析和格式化日期<br>如果已经有一个LocalDate对象，想要创建它的一个修改版，最直接也最简单的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。</p>
<pre><code>// 这段代码中所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象！
LocalDate date1 = LocalDate.of(2017, 12, 15);
LocalDate date2 = date1.withYear(2019);
LocalDate date3 = date2.withDayOfMonth(25);
LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9);
</code></pre><p>它们都声明于Temporal接口，所有的日期和时间API类都实现这两个方法，它们定义了单点的时间，比如LocalDate、LocalTime、LocalDateTime以及Instant。更确切地说，使用get和with方法，我们可以将Temporal对象值的读取和修改区分开。如果Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常，比如试图访问Instant对象的ChronoField.MONTH_OF_YEAR字段，或者LocalDate对象的ChronoField.NANO_OF_SECOND字段时都会抛出这样的异常。</p>
<pre><code>// 以声明的方式操纵LocalDate对象,可以加上或者减去一段时间
LocalDate date1 = LocalDate.of(2014, 10, 19);
LocalDate date2 = date1.plusWeeks(1);
LocalDate date3 = date2.minusYears(3);
LocalDate date4 = date3.plus(6, ChronoUnit.MONTHS);
</code></pre><p>与我们刚才介绍的get和with方法类似最后一行使用的plus方法也是通用方法，它和minus方法都声明于Temporal接口中。通过这些方法，对TemporalUnit对象加上或者减去一个数字，我们能非常方便地将Temporal对象前溯或者回滚至某个时间段，通过ChronoUnit枚举我们可以非常方便地实现TemporalUnit接口。</p>
<p>###6. 使用TemporalAdjuster</p>
<p>有时需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。</p>
<pre><code>// 对于最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问。
LocalDate date1 = LocalDate.of(2013, 12, 11);
LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));
LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());
</code></pre><p>使用TemporalAdjuster可以进行更加复杂的日期操作，方法的名称很直观。如果没有找到符合预期的预定义的TemporalAdjuster，可以创建自定义的TemporalAdjuster。TemporalAdjuster接口只声明一个方法（即函数式接口）。实现该接口需要定义如何将一个Temporal对象转换为另一个Temporal对象,可以把它看成一个UnaryOperator。</p>
<pre><code>@FunctionalInterface
public interface TemporalAdjuster {
    Temporal adjustInto(Temporal temporal);
}
</code></pre><p>###7. 打印输出及解析日期-时间对象</p>
<p>新的java.time.format包就是特别为格式化以及解析日期-时间对象而设计的。其中最重要的类是DateTimeFormatter。创建格式器最简单的方法是通过它的静态工厂方法以及常量。所有的DateTimeFormatter实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<pre><code>LocalDate date = LocalDate.of(2013, 10, 11);
String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);
String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);

20131011
2013-10-11
</code></pre><p>通过解析代表日期或时间的字符串重新创建该日期对象，也可以使用工厂方法parse重新创建。</p>
<pre><code>LocalDate date2 = LocalDate.parse(&quot;20141007&quot;, DateTimeFormatter.BASIC_ISO_DATE);
LocalDate date3 = LocalDate.parse(&quot;2014-10-07&quot;, DateTimeFormatter.ISO_LOCAL_DATE);
</code></pre><p>DateTimeFormatter实例是线程安全的，老的java.util.DateFormat线程不安全。单例模式创建格式器实例，在多个线程间共享实例是没有问题的。也可以通过ofPattern静态工厂方法，按照某个特定的模式创建格式器。</p>
<pre><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);
String formattedDateStr = date.format(formatter);
LocalDate date1 = LocalDate.parse(formattedDateStr, formatter);
</code></pre><p>ofPattern方法也提供了一个重载的版本，可以传入Locale创建格式器。</p>
<pre><code>DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(&quot;d. MMMM yyyy&quot;, Locale.ITALIAN);
LocalDate date = LocalDate.of(2015, 11, 14);
String formattedDate = date.format(italianFormatter);
LocalDate date1 = LocalDate.parse(formattedDate, italianFormatter);
</code></pre><p>DateTimeFormatterBuilder类还提供了更复杂的格式器,以提供更加细粒度的控制。同时也提供非常强大的解析功能，比如区分大小写的解析、柔性解析、填充，以及在格式器中指定可选节等等。</p>
<p>通过DateTimeFormatterBuilder自定义格式器</p>
<pre><code>DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder()
                .appendText(ChronoField.DAY_OF_MONTH)
                .appendLiteral(&quot;. &quot;)
                .appendText(ChronoField.MONTH_OF_YEAR)
                .appendLiteral(&quot; &quot;)
                .appendText(ChronoField.YEAR)
                .parseCaseInsensitive()
                .toFormatter(Locale.ITALIAN);
LocalDate now = LocalDate.now();
String s = now.format(italianFormatter);
</code></pre><p>###8. 处理不同的时区和历法</p>
<p>新版日期和时间API新增加的重要功能是时区的处理。新的java.time.ZoneId类替代老版java.util.TimeZone。跟其他日期和时间类一样，ZoneId类也是无法修改的。是按照一定的规则将区域划分成的标准时间相同的区间。在ZoneRules这个类中包含了40个时区实例,可以通过调用ZoneId的getRules()得到指定时区的规则,每个特定的ZoneId对象都由一个地区ID标识。</p>
<pre><code>ZoneId shanghaiZone = ZoneId.of(&quot;Asia/Shanghai&quot;);
</code></pre><p>Java 8的新方法toZoneId将一个老的时区对象转换为ZoneId。地区ID都为“{区域}/{城市}”的格式，地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p>
<pre><code>ZoneId zoneId = TimeZone.getDefault().toZoneId();
</code></pre><p>ZoneId对象可以与LocalDate、LocalDateTime或者是Instant对象整合构造为成ZonedDateTime实例，它代表了相对于指定时区的时间点。</p>
<pre><code>LocalDate date = LocalDate.of(2019, 03, 27);
ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);

LocalDateTime dateTime = LocalDateTime.of(2015, 12, 21, 11, 11, 11);
ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);

Instant instant = Instant.now();
ZonedDateTime zdt3 = instant.atZone(shanghaiZone);
通过ZoneId，你还可以将LocalDateTime转换为Instant：

LocalDateTime dateTime = LocalDateTime.of(2016, 10, 14, 15, 35);
Instant instantFromDateTime = dateTime.toInstant(shanghaiZone);
你也可以通过反向的方式得到LocalDateTime对象：

Instant instant = Instant.now();
LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, shanghaiZone);
</code></pre><p>另一种比较通用的表达时区的方式是利用当前时区和UTC/格林尼治的固定偏差。使用ZoneId的一个子类ZoneOffset，表示的是当前时间和伦敦格林尼治子午线时间的差异：</p>
<pre><code>ZoneOffset newYorkOffset = ZoneOffset.of(&quot;-05:00&quot;);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/" data-id="cjwkosdyd0006tgv8f9e02b2h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java 10 新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/04/19/java 10 新特性/" class="article-date">
  <time datetime="2019-04-19T12:27:17.449Z" itemprop="datePublished">2019-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/04/19/java 10 新特性/">JAVA 10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java 9才发布几个月，很多玩意都没整明白，现在Java 10又要来了。</p>
<p>这时候我真想说：线上用的JDK 7，甚至JDK 6，而JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……</p>
<p>刚学Java的同学是不是感觉一脸蒙逼？</p>
<p>就连我这个老司机也同样感觉如此！</p>
<p>Java 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。</p>
<p>Java 10的新特性</p>
<p>说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！</p>
<h3 id="1-局部变量类型推断"><a href="#1-局部变量类型推断" class="headerlink" title="1. 局部变量类型推断"></a>1. 局部变量类型推断</h3><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。</p>
<p>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。</p>
<p>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：</p>
<p>将被下面这个新语法所取代：</p>
<p>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。</p>
<p>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。</p>
<p>局部变量类型推荐仅限于如下使用场景：</p>
<p>局部变量初始化for循环内部索引变量传统的for循环声明变量Java官方表示，它不能用于以下几个地方：</p>
<p>方法参数构造函数参数方法返回类型字段捕获表达式（或任何其他类型的变量声明）</p>
<h3 id="2-GC改进和内存管理"><a href="#2-GC改进和内存管理" class="headerlink" title="2. GC改进和内存管理"></a>2. GC改进和内存管理</h3><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。</p>
<p>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。</p>
<p>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p>
<h3 id="3-线程本地握手（JEP-312）"><a href="#3-线程本地握手（JEP-312）" class="headerlink" title="3. 线程本地握手（JEP 312）"></a>3. 线程本地握手（JEP 312）</h3><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p>
<h3 id="4-备用内存设备上的堆分配（JEP-316）"><a href="#4-备用内存设备上的堆分配（JEP-316）" class="headerlink" title="4. 备用内存设备上的堆分配（JEP 316）"></a>4. 备用内存设备上的堆分配（JEP 316）</h3><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p>
<h3 id="5-其他Unicode语言-标记扩展（JEP-314）"><a href="#5-其他Unicode语言-标记扩展（JEP-314）" class="headerlink" title="5. 其他Unicode语言 - 标记扩展（JEP 314）"></a>5. 其他Unicode语言 - 标记扩展（JEP 314）</h3><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p>
<h3 id="6-基于Java的实验性JIT编译器"><a href="#6-基于Java的实验性JIT编译器" class="headerlink" title="6. 基于Java的实验性JIT编译器"></a>6. 基于Java的实验性JIT编译器</h3><p>Oracle希望将其Java JIT编译器Graal用作Linux / x64平台上的实验性JIT编译器。</p>
<h3 id="7-根证书（JEP-319）"><a href="#7-根证书（JEP-319）" class="headerlink" title="7. 根证书（JEP 319）"></a>7. 根证书（JEP 319）</h3><p>这个的目标是在Oracle的Java SE中开源根证书。</p>
<h3 id="8-根证书颁发认证"><a href="#8-根证书颁发认证" class="headerlink" title="8. 根证书颁发认证"></a>8. 根证书颁发认证</h3><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p>
<h3 id="9-将JDK生态整合单个存储库（JEP-296）"><a href="#9-将JDK生态整合单个存储库（JEP-296）" class="headerlink" title="9. 将JDK生态整合单个存储库（JEP 296）"></a>9. 将JDK生态整合单个存储库（JEP 296）</h3><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p>
<h3 id="10-删除工具javah（JEP-313）"><a href="#10-删除工具javah（JEP-313）" class="headerlink" title="10. 删除工具javah（JEP 313）"></a>10. 删除工具javah（JEP 313）</h3><p>从JDK中移除了javah工具，这个很简单并且很重要。</p>
<p>Java 10尝鲜</p>
<p>就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！</p>
<p>尝鲜地址：<a href="http://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk/10/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/04/19/java 10 新特性/" data-id="cjwkosdy10003tgv8xoclei8c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/04/19/hello-world/" class="article-date">
  <time datetime="2019-04-19T10:46:31.439Z" itemprop="datePublished">2019-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/04/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/04/19/hello-world/" data-id="cjwkosdxy0001tgv8jtwwi1ni" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/04/19/测试/" class="article-date">
  <time datetime="2019-04-19T09:49:44.000Z" itemprop="datePublished">2019-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/04/19/测试/">测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/zhaoqixing/my-blog.git/2019/04/19/测试/" data-id="cjwkosdy00002tgv8sz0p3ngw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blog/2019/06/06/Jackson相关/">jackson 相关认识</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/05/31/代理模式/">代理模式</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/05/24/Jackson快速入门/">jackson 快速入门</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/05/10/git回滚远程仓库/">git回滚远程仓库</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/04/30/《Java 8 in Action》Chapter 12：新的日期和时间API/">《Java 8 in Action》Chapter 12：新的日期和时间API</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/my-blog/fancybox/jquery.fancybox.css">
  <script src="/my-blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/my-blog/js/script.js"></script>



  </div>
</body>
</html>